0100 typedef unsigned int   uint;
0101 typedef unsigned short ushort;
0102 typedef unsigned char  uchar;
0103 typedef uint pde_t;
0104 
0105 
0106 
0107 
0108 
0109 
0110 
0111 
0112 
0113 
0114 
0115 
0116 
0117 
0118 
0119 
0120 
0121 
0122 
0123 
0124 
0125 
0126 
0127 
0128 
0129 
0130 
0131 
0132 
0133 
0134 
0135 
0136 
0137 
0138 
0139 
0140 
0141 
0142 
0143 
0144 
0145 
0146 
0147 
0148 
0149 
0150 #define NPROC        64  
0151 #define KSTACKSIZE 4096  
0152 #define NCPU          8  
0153 #define NOFILE       16  
0154 #define NFILE       100  
0155 #define NINODE       50  
0156 #define NDEV         10  
0157 #define ROOTDEV       1  
0158 #define MAXARG       32  
0159 #define MAXOPBLOCKS  10  
0160 #define LOGSIZE      (MAXOPBLOCKS*3)  
0161 #define NBUF         (MAXOPBLOCKS*3)  
0162 #define FSSIZE       1000  
0163 
0164 
0165 
0166 
0167 
0168 
0169 
0170 
0171 
0172 
0173 
0174 
0175 
0176 
0177 
0178 
0179 
0180 
0181 
0182 
0183 
0184 
0185 
0186 
0187 
0188 
0189 
0190 
0191 
0192 
0193 
0194 
0195 
0196 
0197 
0198 
0199 
0200 
0201 
0202 #define EXTMEM  0x100000            
0203 #define PHYSTOP 0xE000000           
0204 #define DEVSPACE 0xFE000000         
0205 
0206 
0207 #define KERNBASE 0x80000000         
0208 #define KERNLINK (KERNBASE+EXTMEM)  
0209 
0210 
0211 #define V2P(a) (((uint) (a)) - KERNBASE)
0212 #define P2V(a) (((void *) (a)) + KERNBASE)
0213 
0214 #define V2P_WO(x) ((x) - KERNBASE)    
0215 #define P2V_WO(x) ((x) + KERNBASE)    
0216 
0217 
0218 
0219 
0220 
0221 
0222 
0223 
0224 
0225 
0226 
0227 
0228 
0229 
0230 
0231 
0232 
0233 
0234 
0235 
0236 
0237 
0238 
0239 
0240 
0241 
0242 
0243 
0244 
0245 
0246 
0247 
0248 
0249 
0250 struct buf;
0251 struct context;
0252 struct file;
0253 struct inode;
0254 struct pipe;
0255 struct proc;
0256 struct rtcdate;
0257 struct spinlock;
0258 struct sleeplock;
0259 struct stat;
0260 struct superblock;
0261 
0262 
0263 void            binit(void);
0264 struct buf*     bread(uint, uint);
0265 void            brelse(struct buf*);
0266 void            bwrite(struct buf*);
0267 
0268 
0269 void            consoleinit(void);
0270 void            cprintf(char*, ...);
0271 void            consoleintr(int(*)(void));
0272 void            panic(char*) __attribute__((noreturn));
0273 
0274 
0275 int             exec(char*, char**);
0276 
0277 
0278 struct file*    filealloc(void);
0279 void            fileclose(struct file*);
0280 struct file*    filedup(struct file*);
0281 void            fileinit(void);
0282 int             fileread(struct file*, char*, int n);
0283 int             filestat(struct file*, struct stat*);
0284 int             filewrite(struct file*, char*, int n);
0285 
0286 
0287 void            readsb(int dev, struct superblock *sb);
0288 int             dirlink(struct inode*, char*, uint);
0289 struct inode*   dirlookup(struct inode*, char*, uint*);
0290 struct inode*   ialloc(uint, short);
0291 struct inode*   idup(struct inode*);
0292 void            iinit(int dev);
0293 void            ilock(struct inode*);
0294 void            iput(struct inode*);
0295 void            iunlock(struct inode*);
0296 void            iunlockput(struct inode*);
0297 void            iupdate(struct inode*);
0298 int             namecmp(const char*, const char*);
0299 struct inode*   namei(char*);
0300 struct inode*   nameiparent(char*, char*);
0301 int             readi(struct inode*, char*, uint, uint);
0302 void            stati(struct inode*, struct stat*);
0303 int             writei(struct inode*, char*, uint, uint);
0304 
0305 
0306 void            ideinit(void);
0307 void            ideintr(void);
0308 void            iderw(struct buf*);
0309 
0310 
0311 void            ioapicenable(int irq, int cpu);
0312 extern uchar    ioapicid;
0313 void            ioapicinit(void);
0314 
0315 
0316 char*           kalloc(void);
0317 void            kfree(char*);
0318 void            kinit1(void*, void*);
0319 void            kinit2(void*, void*);
0320 
0321 
0322 void            kbdintr(void);
0323 
0324 
0325 void            cmostime(struct rtcdate *r);
0326 int             cpunum(void);
0327 extern volatile uint*    lapic;
0328 void            lapiceoi(void);
0329 void            lapicinit(void);
0330 void            lapicstartap(uchar, uint);
0331 void            microdelay(int);
0332 
0333 
0334 void            initlog(int dev);
0335 void            log_write(struct buf*);
0336 void            begin_op();
0337 void            end_op();
0338 
0339 
0340 extern int      ismp;
0341 void            mpinit(void);
0342 
0343 
0344 void            picenable(int);
0345 void            picinit(void);
0346 
0347 
0348 
0349 
0350 
0351 int             pipealloc(struct file**, struct file**);
0352 void            pipeclose(struct pipe*, int);
0353 int             piperead(struct pipe*, char*, int);
0354 int             pipewrite(struct pipe*, char*, int);
0355 
0356 
0357 
0358 void            exit(void);
0359 int             fork(void);
0360 int             growproc(int);
0361 int             kill(int);
0362 void            pinit(void);
0363 void            procdump(void);
0364 void            scheduler(void) __attribute__((noreturn));
0365 void            sched(void);
0366 void            sleep(void*, struct spinlock*);
0367 void            userinit(void);
0368 int             wait(void);
0369 void            wakeup(void*);
0370 void            yield(void);
0371 
0372 
0373 void            swtch(struct context**, struct context*);
0374 
0375 
0376 void            acquire(struct spinlock*);
0377 void            getcallerpcs(void*, uint*);
0378 int             holding(struct spinlock*);
0379 void            initlock(struct spinlock*, char*);
0380 void            release(struct spinlock*);
0381 void            pushcli(void);
0382 void            popcli(void);
0383 
0384 
0385 void            acquiresleep(struct sleeplock*);
0386 void            releasesleep(struct sleeplock*);
0387 int             holdingsleep(struct sleeplock*);
0388 void            initsleeplock(struct sleeplock*, char*);
0389 
0390 
0391 int             memcmp(const void*, const void*, uint);
0392 void*           memmove(void*, const void*, uint);
0393 void*           memset(void*, int, uint);
0394 char*           safestrcpy(char*, const char*, int);
0395 int             strlen(const char*);
0396 int             strncmp(const char*, const char*, uint);
0397 char*           strncpy(char*, const char*, int);
0398 
0399 
0400 
0401 int             argint(int, int*);
0402 int             argptr(int, char**, int);
0403 int             argstr(int, char**);
0404 int             fetchint(uint, int*);
0405 int             fetchstr(uint, char**);
0406 void            syscall(void);
0407 
0408 
0409 void            timerinit(void);
0410 
0411 
0412 void            idtinit(void);
0413 extern uint     ticks;
0414 void            tvinit(void);
0415 extern struct spinlock tickslock;
0416 
0417 
0418 void            uartinit(void);
0419 void            uartintr(void);
0420 void            uartputc(int);
0421 
0422 
0423 void            seginit(void);
0424 void            kvmalloc(void);
0425 pde_t*          setupkvm(void);
0426 char*           uva2ka(pde_t*, char*);
0427 int             allocuvm(pde_t*, uint, uint);
0428 int             deallocuvm(pde_t*, uint, uint);
0429 void            freevm(pde_t*);
0430 void            inituvm(pde_t*, char*, uint);
0431 int             loaduvm(pde_t*, char*, struct inode*, uint, uint);
0432 pde_t*          copyuvm(pde_t*, uint);
0433 void            switchuvm(struct proc*);
0434 void            switchkvm(void);
0435 int             copyout(pde_t*, uint, void*, uint);
0436 void            clearpteu(pde_t *pgdir, char *uva);
0437 
0438 
0439 #define NELEM(x) (sizeof(x)/sizeof((x)[0]))
0440 
0441 
0442 
0443 
0444 
0445 
0446 
0447 
0448 
0449 
0450 
0451 
0452 static inline uchar
0453 inb(ushort port)
0454 {
0455   uchar data;
0456 
0457   asm volatile("in %1,%0" : "=a" (data) : "d" (port));
0458   return data;
0459 }
0460 
0461 static inline void
0462 insl(int port, void *addr, int cnt)
0463 {
0464   asm volatile("cld; rep insl" :
0465                "=D" (addr), "=c" (cnt) :
0466                "d" (port), "0" (addr), "1" (cnt) :
0467                "memory", "cc");
0468 }
0469 
0470 static inline void
0471 outb(ushort port, uchar data)
0472 {
0473   asm volatile("out %0,%1" : : "a" (data), "d" (port));
0474 }
0475 
0476 static inline void
0477 outw(ushort port, ushort data)
0478 {
0479   asm volatile("out %0,%1" : : "a" (data), "d" (port));
0480 }
0481 
0482 static inline void
0483 outsl(int port, const void *addr, int cnt)
0484 {
0485   asm volatile("cld; rep outsl" :
0486                "=S" (addr), "=c" (cnt) :
0487                "d" (port), "0" (addr), "1" (cnt) :
0488                "cc");
0489 }
0490 
0491 static inline void
0492 stosb(void *addr, int data, int cnt)
0493 {
0494   asm volatile("cld; rep stosb" :
0495                "=D" (addr), "=c" (cnt) :
0496                "0" (addr), "1" (cnt), "a" (data) :
0497                "memory", "cc");
0498 }
0499 
0500 static inline void
0501 stosl(void *addr, int data, int cnt)
0502 {
0503   asm volatile("cld; rep stosl" :
0504                "=D" (addr), "=c" (cnt) :
0505                "0" (addr), "1" (cnt), "a" (data) :
0506                "memory", "cc");
0507 }
0508 
0509 struct segdesc;
0510 
0511 static inline void
0512 lgdt(struct segdesc *p, int size)
0513 {
0514   volatile ushort pd[3];
0515 
0516   pd[0] = size-1;
0517   pd[1] = (uint)p;
0518   pd[2] = (uint)p >> 16;
0519 
0520   asm volatile("lgdt (%0)" : : "r" (pd));
0521 }
0522 
0523 struct gatedesc;
0524 
0525 static inline void
0526 lidt(struct gatedesc *p, int size)
0527 {
0528   volatile ushort pd[3];
0529 
0530   pd[0] = size-1;
0531   pd[1] = (uint)p;
0532   pd[2] = (uint)p >> 16;
0533 
0534   asm volatile("lidt (%0)" : : "r" (pd));
0535 }
0536 
0537 static inline void
0538 ltr(ushort sel)
0539 {
0540   asm volatile("ltr %0" : : "r" (sel));
0541 }
0542 
0543 static inline uint
0544 readeflags(void)
0545 {
0546   uint eflags;
0547   asm volatile("pushfl; popl %0" : "=r" (eflags));
0548   return eflags;
0549 }
0550 static inline void
0551 loadgs(ushort v)
0552 {
0553   asm volatile("movw %0, %%gs" : : "r" (v));
0554 }
0555 
0556 static inline void
0557 cli(void)
0558 {
0559   asm volatile("cli");
0560 }
0561 
0562 static inline void
0563 sti(void)
0564 {
0565   asm volatile("sti");
0566 }
0567 
0568 static inline uint
0569 xchg(volatile uint *addr, uint newval)
0570 {
0571   uint result;
0572 
0573   
0574   asm volatile("lock; xchgl %0, %1" :
0575                "+m" (*addr), "=a" (result) :
0576                "1" (newval) :
0577                "cc");
0578   return result;
0579 }
0580 
0581 static inline uint
0582 rcr2(void)
0583 {
0584   uint val;
0585   asm volatile("movl %%cr2,%0" : "=r" (val));
0586   return val;
0587 }
0588 
0589 static inline void
0590 lcr3(uint val)
0591 {
0592   asm volatile("movl %0,%%cr3" : : "r" (val));
0593 }
0594 
0595 
0596 
0597 
0598 
0599 
0600 
0601 
0602 struct trapframe {
0603   
0604   uint edi;
0605   uint esi;
0606   uint ebp;
0607   uint oesp;      
0608   uint ebx;
0609   uint edx;
0610   uint ecx;
0611   uint eax;
0612 
0613   
0614   ushort gs;
0615   ushort padding1;
0616   ushort fs;
0617   ushort padding2;
0618   ushort es;
0619   ushort padding3;
0620   ushort ds;
0621   ushort padding4;
0622   uint trapno;
0623 
0624   
0625   uint err;
0626   uint eip;
0627   ushort cs;
0628   ushort padding5;
0629   uint eflags;
0630 
0631   
0632   uint esp;
0633   ushort ss;
0634   ushort padding6;
0635 };
0636 
0637 
0638 
0639 
0640 
0641 
0642 
0643 
0644 
0645 
0646 
0647 
0648 
0649 
0650 
0651 
0652 
0653 
0654 #define SEG_NULLASM                                             \
0655         .word 0, 0;                                             \
0656         .byte 0, 0, 0, 0
0657 
0658 
0659 
0660 #define SEG_ASM(type,base,lim)                                  \
0661         .word (((lim) >> 12) & 0xffff), ((base) & 0xffff);      \
0662         .byte (((base) >> 16) & 0xff), (0x90 | (type)),         \
0663                 (0xC0 | (((lim) >> 28) & 0xf)), (((base) >> 24) & 0xff)
0664 
0665 #define STA_X     0x8       
0666 #define STA_E     0x4       
0667 #define STA_C     0x4       
0668 #define STA_W     0x2       
0669 #define STA_R     0x2       
0670 #define STA_A     0x1       
0671 
0672 
0673 
0674 
0675 
0676 
0677 
0678 
0679 
0680 
0681 
0682 
0683 
0684 
0685 
0686 
0687 
0688 
0689 
0690 
0691 
0692 
0693 
0694 
0695 
0696 
0697 
0698 
0699 
0700 
0701 
0702 
0703 
0704 #define FL_CF           0x00000001      
0705 #define FL_PF           0x00000004      
0706 #define FL_AF           0x00000010      
0707 #define FL_ZF           0x00000040      
0708 #define FL_SF           0x00000080      
0709 #define FL_TF           0x00000100      
0710 #define FL_IF           0x00000200      
0711 #define FL_DF           0x00000400      
0712 #define FL_OF           0x00000800      
0713 #define FL_IOPL_MASK    0x00003000      
0714 #define FL_IOPL_0       0x00000000      
0715 #define FL_IOPL_1       0x00001000      
0716 #define FL_IOPL_2       0x00002000      
0717 #define FL_IOPL_3       0x00003000      
0718 #define FL_NT           0x00004000      
0719 #define FL_RF           0x00010000      
0720 #define FL_VM           0x00020000      
0721 #define FL_AC           0x00040000      
0722 #define FL_VIF          0x00080000      
0723 #define FL_VIP          0x00100000      
0724 #define FL_ID           0x00200000      
0725 
0726 
0727 #define CR0_PE          0x00000001      
0728 #define CR0_MP          0x00000002      
0729 #define CR0_EM          0x00000004      
0730 #define CR0_TS          0x00000008      
0731 #define CR0_ET          0x00000010      
0732 #define CR0_NE          0x00000020      
0733 #define CR0_WP          0x00010000      
0734 #define CR0_AM          0x00040000      
0735 #define CR0_NW          0x20000000      
0736 #define CR0_CD          0x40000000      
0737 #define CR0_PG          0x80000000      
0738 
0739 #define CR4_PSE         0x00000010      
0740 
0741 
0742 #define SEG_KCODE 1  
0743 #define SEG_KDATA 2  
0744 #define SEG_KCPU  3  
0745 #define SEG_UCODE 4  
0746 #define SEG_UDATA 5  
0747 #define SEG_TSS   6  
0748 
0749 
0750 
0751 #define NSEGS     7
0752 
0753 
0754 
0755 
0756 
0757 
0758 
0759 
0760 
0761 
0762 
0763 
0764 
0765 
0766 
0767 
0768 
0769 
0770 
0771 
0772 
0773 
0774 
0775 
0776 
0777 
0778 
0779 
0780 
0781 
0782 
0783 
0784 
0785 
0786 
0787 
0788 
0789 
0790 
0791 
0792 
0793 
0794 
0795 
0796 
0797 
0798 
0799 
0800 #ifndef __ASSEMBLER__
0801 
0802 struct segdesc {
0803   uint lim_15_0 : 16;  
0804   uint base_15_0 : 16; 
0805   uint base_23_16 : 8; 
0806   uint type : 4;       
0807   uint s : 1;          
0808   uint dpl : 2;        
0809   uint p : 1;          
0810   uint lim_19_16 : 4;  
0811   uint avl : 1;        
0812   uint rsv1 : 1;       
0813   uint db : 1;         
0814   uint g : 1;          
0815   uint base_31_24 : 8; 
0816 };
0817 
0818 
0819 #define SEG(type, base, lim, dpl) (struct segdesc)    \
0820 { ((lim) >> 12) & 0xffff, (uint)(base) & 0xffff,      \
0821   ((uint)(base) >> 16) & 0xff, type, 1, dpl, 1,       \
0822   (uint)(lim) >> 28, 0, 0, 1, 1, (uint)(base) >> 24 }
0823 #define SEG16(type, base, lim, dpl) (struct segdesc)  \
0824 { (lim) & 0xffff, (uint)(base) & 0xffff,              \
0825   ((uint)(base) >> 16) & 0xff, type, 1, dpl, 1,       \
0826   (uint)(lim) >> 16, 0, 0, 1, 0, (uint)(base) >> 24 }
0827 #endif
0828 
0829 #define DPL_USER    0x3     
0830 
0831 
0832 #define STA_X       0x8     
0833 #define STA_E       0x4     
0834 #define STA_C       0x4     
0835 #define STA_W       0x2     
0836 #define STA_R       0x2     
0837 #define STA_A       0x1     
0838 
0839 
0840 #define STS_T16A    0x1     
0841 #define STS_LDT     0x2     
0842 #define STS_T16B    0x3     
0843 #define STS_CG16    0x4     
0844 #define STS_TG      0x5     
0845 #define STS_IG16    0x6     
0846 #define STS_TG16    0x7     
0847 #define STS_T32A    0x9     
0848 #define STS_T32B    0xB     
0849 #define STS_CG32    0xC     
0850 #define STS_IG32    0xE     
0851 #define STS_TG32    0xF     
0852 
0853 
0854 
0855 
0856 
0857 
0858 
0859 
0860 
0861 
0862 #define PDX(va)         (((uint)(va) >> PDXSHIFT) & 0x3FF)
0863 
0864 
0865 #define PTX(va)         (((uint)(va) >> PTXSHIFT) & 0x3FF)
0866 
0867 
0868 #define PGADDR(d, t, o) ((uint)((d) << PDXSHIFT | (t) << PTXSHIFT | (o)))
0869 
0870 
0871 #define NPDENTRIES      1024    
0872 #define NPTENTRIES      1024    
0873 #define PGSIZE          4096    
0874 
0875 #define PGSHIFT         12      
0876 #define PTXSHIFT        12      
0877 #define PDXSHIFT        22      
0878 
0879 #define PGROUNDUP(sz)  (((sz)+PGSIZE-1) & ~(PGSIZE-1))
0880 #define PGROUNDDOWN(a) (((a)) & ~(PGSIZE-1))
0881 
0882 
0883 #define PTE_P           0x001   
0884 #define PTE_W           0x002   
0885 #define PTE_U           0x004   
0886 #define PTE_PWT         0x008   
0887 #define PTE_PCD         0x010   
0888 #define PTE_A           0x020   
0889 #define PTE_D           0x040   
0890 #define PTE_PS          0x080   
0891 #define PTE_MBZ         0x180   
0892 
0893 
0894 #define PTE_ADDR(pte)   ((uint)(pte) & ~0xFFF)
0895 #define PTE_FLAGS(pte)  ((uint)(pte) &  0xFFF)
0896 
0897 #ifndef __ASSEMBLER__
0898 typedef uint pte_t;
0899 
0900 
0901 struct taskstate {
0902   uint link;         
0903   uint esp0;         
0904   ushort ss0;        
0905   ushort padding1;
0906   uint *esp1;
0907   ushort ss1;
0908   ushort padding2;
0909   uint *esp2;
0910   ushort ss2;
0911   ushort padding3;
0912   void *cr3;         
0913   uint *eip;         
0914   uint eflags;
0915   uint eax;          
0916   uint ecx;
0917   uint edx;
0918   uint ebx;
0919   uint *esp;
0920   uint *ebp;
0921   uint esi;
0922   uint edi;
0923   ushort es;         
0924   ushort padding4;
0925   ushort cs;
0926   ushort padding5;
0927   ushort ss;
0928   ushort padding6;
0929   ushort ds;
0930   ushort padding7;
0931   ushort fs;
0932   ushort padding8;
0933   ushort gs;
0934   ushort padding9;
0935   ushort ldt;
0936   ushort padding10;
0937   ushort t;          
0938   ushort iomb;       
0939 };
0940 
0941 
0942 
0943 
0944 
0945 
0946 
0947 
0948 
0949 
0950 
0951 struct gatedesc {
0952   uint off_15_0 : 16;   
0953   uint cs : 16;         
0954   uint args : 5;        
0955   uint rsv1 : 3;        
0956   uint type : 4;        
0957   uint s : 1;           
0958   uint dpl : 2;         
0959   uint p : 1;           
0960   uint off_31_16 : 16;  
0961 };
0962 
0963 
0964 
0965 
0966 
0967 
0968 
0969 
0970 
0971 #define SETGATE(gate, istrap, sel, off, d)                \
0972 {                                                         \
0973   (gate).off_15_0 = (uint)(off) & 0xffff;                \
0974   (gate).cs = (sel);                                      \
0975   (gate).args = 0;                                        \
0976   (gate).rsv1 = 0;                                        \
0977   (gate).type = (istrap) ? STS_TG32 : STS_IG32;           \
0978   (gate).s = 0;                                           \
0979   (gate).dpl = (d);                                       \
0980   (gate).p = 1;                                           \
0981   (gate).off_31_16 = (uint)(off) >> 16;                  \
0982 }
0983 
0984 #endif
0985 
0986 
0987 
0988 
0989 
0990 
0991 
0992 
0993 
0994 
0995 
0996 
0997 
0998 
0999 
1000 
1001 
1002 #define ELF_MAGIC 0x464C457FU  
1003 
1004 
1005 struct elfhdr {
1006   uint magic;  
1007   uchar elf[12];
1008   ushort type;
1009   ushort machine;
1010   uint version;
1011   uint entry;
1012   uint phoff;
1013   uint shoff;
1014   uint flags;
1015   ushort ehsize;
1016   ushort phentsize;
1017   ushort phnum;
1018   ushort shentsize;
1019   ushort shnum;
1020   ushort shstrndx;
1021 };
1022 
1023 
1024 struct proghdr {
1025   uint type;
1026   uint off;
1027   uint vaddr;
1028   uint paddr;
1029   uint filesz;
1030   uint memsz;
1031   uint flags;
1032   uint align;
1033 };
1034 
1035 
1036 #define ELF_PROG_LOAD           1
1037 
1038 
1039 #define ELF_PROG_FLAG_EXEC      1
1040 #define ELF_PROG_FLAG_WRITE     2
1041 #define ELF_PROG_FLAG_READ      4
1042 
1043 
1044 
1045 
1046 
1047 
1048 
1049 
1050 
1051 
1052 
1053 
1054 
1055 
1056 
1057 
1058 
1059 
1060 
1061 
1062 
1063 
1064 
1065 
1066 
1067 
1068 
1069 
1070 
1071 
1072 
1073 
1074 
1075 
1076 
1077 
1078 
1079 
1080 
1081 
1082 
1083 
1084 
1085 
1086 
1087 
1088 
1089 
1090 
1091 
1092 
1093 
1094 
1095 
1096 
1097 
1098 
1099 
1100 
1101 
1102 
1103 
1104 
1105 
1106 
1107 
1108 
1109 
1110 
1111 
1112 
1113 
1114 
1115 
1116 
1117 
1118 
1119 
1120 
1121 
1122 
1123 
1124 
1125 
1126 .p2align 2
1127 .text
1128 .globl multiboot_header
1129 multiboot_header:
1130   
1131   
1132   .long magic
1133   .long flags
1134   .long (-magic-flags)
1135 
1136 
1137 
1138 
1139 .globl _start
1140 _start = V2P_WO(entry)
1141 
1142 
1143 .globl entry
1144 entry:
1145   
1146   movl    %cr4, %eax
1147   orl     $(CR4_PSE), %eax
1148   movl    %eax, %cr4
1149   
1150   movl    $(V2P_WO(entrypgdir)), %eax
1151   movl    %eax, %cr3
1152   
1153   movl    %cr0, %eax
1154   orl     $(CR0_PG|CR0_WP), %eax
1155   movl    %eax, %cr0
1156 
1157   
1158   movl $(stack + KSTACKSIZE), %esp
1159 
1160   
1161   
1162   
1163   
1164   mov $main, %eax
1165   jmp *%eax
1166 
1167 .comm stack, KSTACKSIZE
1168 
1169 
1170 
1171 
1172 
1173 
1174 
1175 
1176 
1177 
1178 
1179 
1180 
1181 
1182 
1183 
1184 
1185 
1186 
1187 
1188 
1189 
1190 
1191 
1192 
1193 
1194 
1195 
1196 
1197 
1198 
1199 
1200 
1201 
1202 
1203 
1204 
1205 
1206 
1207 
1208 
1209 
1210 
1211 
1212 
1213 
1214 
1215 
1216 
1217 
1218 
1219 
1220 
1221 .code16
1222 .globl start
1223 start:
1224   cli
1225 
1226   
1227   xorw    %ax,%ax
1228   movw    %ax,%ds
1229   movw    %ax,%es
1230   movw    %ax,%ss
1231 
1232   
1233   
1234   
1235   lgdt    gdtdesc
1236   movl    %cr0, %eax
1237   orl     $CR0_PE, %eax
1238   movl    %eax, %cr0
1239 
1240   
1241   
1242   
1243   ljmpl    $(SEG_KCODE<<3), $(start32)
1244 
1245 
1246 
1247 
1248 
1249 
1250 .code32  
1251 start32:
1252   
1253   movw    $(SEG_KDATA<<3), %ax    
1254   movw    %ax, %ds                
1255   movw    %ax, %es                
1256   movw    %ax, %ss                
1257   movw    $0, %ax                 
1258   movw    %ax, %fs                
1259   movw    %ax, %gs                
1260 
1261   
1262   movl    %cr4, %eax
1263   orl     $(CR4_PSE), %eax
1264   movl    %eax, %cr4
1265   
1266   movl    (start-12), %eax
1267   movl    %eax, %cr3
1268   
1269   movl    %cr0, %eax
1270   orl     $(CR0_PE|CR0_PG|CR0_WP), %eax
1271   movl    %eax, %cr0
1272 
1273   
1274   movl    (start-4), %esp
1275   
1276   call	 *(start-8)
1277 
1278   movw    $0x8a00, %ax
1279   movw    %ax, %dx
1280   outw    %ax, %dx
1281   movw    $0x8ae0, %ax
1282   outw    %ax, %dx
1283 spin:
1284   jmp     spin
1285 
1286 .p2align 2
1287 gdt:
1288   SEG_NULLASM
1289   SEG_ASM(STA_X|STA_R, 0, 0xffffffff)
1290   SEG_ASM(STA_W, 0, 0xffffffff)
1291 
1292 
1293 gdtdesc:
1294   .word   (gdtdesc - gdt - 1)
1295   .long   gdt
1296 
1297 
1298 
1299 
1300 #include "types.h"
1301 #include "defs.h"
1302 #include "param.h"
1303 #include "memlayout.h"
1304 #include "mmu.h"
1305 #include "proc.h"
1306 #include "x86.h"
1307 
1308 static void startothers(void);
1309 static void mpmain(void)  __attribute__((noreturn));
1310 extern pde_t *kpgdir;
1311 extern char end[]; 
1312 
1313 
1314 
1315 
1316 int
1317 main(void)
1318 {
1319   
1320   
1321   kinit1(end, P2V(4*1024*1024)); 
1322 
1323   
1324   
1325   
1326   kvmalloc();      
1327 
1328   mpinit();        
1329   lapicinit();     
1330   seginit();       
1331   cprintf("\ncpu%d: starting xv6\n\n", cpunum());
1332   picinit();       
1333   ioapicinit();    
1334   consoleinit();   
1335   uartinit();      
1336   pinit();         
1337 
1338   
1339   
1340   tvinit();        
1341 
1342   binit();         
1343   fileinit();      
1344   ideinit();       
1345   if(!ismp)
1346     timerinit();   
1347   startothers();   
1348   kinit2(P2V(4*1024*1024), P2V(PHYSTOP)); 
1349   userinit();      
1350   mpmain();        
1351 }
1352 
1353 
1354 static void
1355 mpenter(void)
1356 {
1357   switchkvm();
1358   seginit();
1359   lapicinit();
1360   mpmain();
1361 }
1362 
1363 
1364 static void
1365 mpmain(void)
1366 {
1367   cprintf("cpu%d: starting\n", cpunum());
1368   idtinit();       
1369   xchg(&cpu->started, 1); 
1370   scheduler();     
1371 }
1372 
1373 pde_t entrypgdir[];  
1374 
1375 
1376 static void
1377 startothers(void)
1378 {
1379   extern uchar _binary_entryother_start[], _binary_entryother_size[];
1380   uchar *code;
1381   struct cpu *c;
1382   char *stack;
1383 
1384   
1385   
1386   
1387   code = P2V(0x7000);
1388   memmove(code, _binary_entryother_start, (uint)_binary_entryother_size);
1389 
1390   for(c = cpus; c < cpus+ncpu; c++){
1391     if(c == cpus+cpunum())  
1392       continue;
1393 
1394     
1395     
1396     
1397     stack = kalloc();
1398     *(void**)(code-4) = stack + KSTACKSIZE;
1399     *(void**)(code-8) = mpenter;
1400     *(int**)(code-12) = (void *) V2P(entrypgdir);
1401 
1402     lapicstartap(c->apicid, V2P(code));
1403 
1404     
1405     while(c->started == 0)
1406       ;
1407   }
1408 }
1409 
1410 
1411 
1412 
1413 
1414 
1415 __attribute__((__aligned__(PGSIZE)))
1416 pde_t entrypgdir[NPDENTRIES] = {
1417   
1418   [0] = (0) | PTE_P | PTE_W | PTE_PS,
1419   
1420   [KERNBASE>>PDXSHIFT] = (0) | PTE_P | PTE_W | PTE_PS,
1421 };
1422 
1423 
1424 
1425 
1426 
1427 
1428 
1429 
1430 
1431 
1432 
1433 
1434 
1435 
1436 
1437 
1438 
1439 
1440 
1441 
1442 
1443 
1444 
1445 
1446 
1447 
1448 
1449 
1450 
1451 
1452 
1453 
1454 
1455 
1456 
1457 
1458 
1459 
1460 
1461 
1462 
1463 
1464 
1465 
1466 
1467 
1468 
1469 
1470 
1471 
1472 
1473 
1474 
1475 
1476 
1477 
1478 
1479 
1480 
1481 
1482 
1483 
1484 
1485 
1486 
1487 
1488 
1489 
1490 
1491 
1492 
1493 
1494 
1495 
1496 
1497 
1498 
1499 
1500 
1501 struct spinlock {
1502   uint locked;       
1503 
1504   
1505   char *name;        
1506   struct cpu *cpu;   
1507   uint pcs[10];      
1508                      
1509 };
1510 
1511 
1512 
1513 
1514 
1515 
1516 
1517 
1518 
1519 
1520 
1521 
1522 
1523 
1524 
1525 
1526 
1527 
1528 
1529 
1530 
1531 
1532 
1533 
1534 
1535 
1536 
1537 
1538 
1539 
1540 
1541 
1542 
1543 
1544 
1545 
1546 
1547 
1548 
1549 
1550 
1551 
1552 #include "types.h"
1553 #include "defs.h"
1554 #include "param.h"
1555 #include "x86.h"
1556 #include "memlayout.h"
1557 #include "mmu.h"
1558 #include "proc.h"
1559 #include "spinlock.h"
1560 
1561 void
1562 initlock(struct spinlock *lk, char *name)
1563 {
1564   lk->name = name;
1565   lk->locked = 0;
1566   lk->cpu = 0;
1567 }
1568 
1569 
1570 
1571 
1572 
1573 void
1574 acquire(struct spinlock *lk)
1575 {
1576   pushcli(); 
1577   if(holding(lk))
1578     panic("acquire");
1579 
1580   
1581   while(xchg(&lk->locked, 1) != 0)
1582     ;
1583 
1584   
1585   
1586   
1587   __sync_synchronize();
1588 
1589   
1590   lk->cpu = cpu;
1591   getcallerpcs(&lk, lk->pcs);
1592 }
1593 
1594 
1595 
1596 
1597 
1598 
1599 
1600 
1601 void
1602 release(struct spinlock *lk)
1603 {
1604   if(!holding(lk))
1605     panic("release");
1606 
1607   lk->pcs[0] = 0;
1608   lk->cpu = 0;
1609 
1610   
1611   
1612   
1613   
1614   
1615   __sync_synchronize();
1616 
1617   
1618   
1619   
1620   asm volatile("movl $0, %0" : "+m" (lk->locked) : );
1621 
1622   popcli();
1623 }
1624 
1625 
1626 void
1627 getcallerpcs(void *v, uint pcs[])
1628 {
1629   uint *ebp;
1630   int i;
1631 
1632   ebp = (uint*)v - 2;
1633   for(i = 0; i < 10; i++){
1634     if(ebp == 0 || ebp < (uint*)KERNBASE || ebp == (uint*)0xffffffff)
1635       break;
1636     pcs[i] = ebp[1];     
1637     ebp = (uint*)ebp[0]; 
1638   }
1639   for(; i < 10; i++)
1640     pcs[i] = 0;
1641 }
1642 
1643 
1644 int
1645 holding(struct spinlock *lock)
1646 {
1647   return lock->locked && lock->cpu == cpu;
1648 }
1649 
1650 
1651 
1652 
1653 
1654 void
1655 pushcli(void)
1656 {
1657   int eflags;
1658 
1659   eflags = readeflags();
1660   cli();
1661   if(cpu->ncli == 0)
1662     cpu->intena = eflags & FL_IF;
1663   cpu->ncli += 1;
1664 }
1665 
1666 void
1667 popcli(void)
1668 {
1669   if(readeflags()&FL_IF)
1670     panic("popcli - interruptible");
1671   if(--cpu->ncli < 0)
1672     panic("popcli");
1673   if(cpu->ncli == 0 && cpu->intena)
1674     sti();
1675 }
1676 
1677 
1678 
1679 
1680 
1681 
1682 
1683 
1684 
1685 
1686 
1687 
1688 
1689 
1690 
1691 
1692 
1693 
1694 
1695 
1696 
1697 
1698 
1699 
1700 #include "param.h"
1701 #include "types.h"
1702 #include "defs.h"
1703 #include "x86.h"
1704 #include "memlayout.h"
1705 #include "mmu.h"
1706 #include "proc.h"
1707 #include "elf.h"
1708 
1709 extern char data[];  
1710 pde_t *kpgdir;  
1711 
1712 
1713 
1714 void
1715 seginit(void)
1716 {
1717   struct cpu *c;
1718 
1719   
1720   
1721   
1722   
1723   c = &cpus[cpunum()];
1724   c->gdt[SEG_KCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, 0);
1725   c->gdt[SEG_KDATA] = SEG(STA_W, 0, 0xffffffff, 0);
1726   c->gdt[SEG_UCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, DPL_USER);
1727   c->gdt[SEG_UDATA] = SEG(STA_W, 0, 0xffffffff, DPL_USER);
1728 
1729   
1730   c->gdt[SEG_KCPU] = SEG(STA_W, &c->cpu, 8, 0);
1731 
1732   lgdt(c->gdt, sizeof(c->gdt));
1733   loadgs(SEG_KCPU << 3);
1734 
1735   
1736   cpu = c;
1737   proc = 0;
1738 }
1739 
1740 
1741 
1742 
1743 
1744 
1745 
1746 
1747 
1748 
1749 
1750 
1751 
1752 
1753 static pte_t *
1754 walkpgdir(pde_t *pgdir, const void *va, int alloc)
1755 {
1756   pde_t *pde;
1757   pte_t *pgtab;
1758 
1759   pde = &pgdir[PDX(va)];
1760   if(*pde & PTE_P){
1761     pgtab = (pte_t*)P2V(PTE_ADDR(*pde));
1762   } else {
1763     if(!alloc || (pgtab = (pte_t*)kalloc()) == 0)
1764       return 0;
1765     
1766     memset(pgtab, 0, PGSIZE);
1767     
1768     
1769     
1770     *pde = V2P(pgtab) | PTE_P | PTE_W | PTE_U;
1771   }
1772   return &pgtab[PTX(va)];
1773 }
1774 
1775 
1776 
1777 
1778 static int
1779 mappages(pde_t *pgdir, void *va, uint size, uint pa, int perm)
1780 {
1781   char *a, *last;
1782   pte_t *pte;
1783 
1784   a = (char*)PGROUNDDOWN((uint)va);
1785   last = (char*)PGROUNDDOWN(((uint)va) + size - 1);
1786   for(;;){
1787     
1788     
1789     if((pte = walkpgdir(pgdir, a, 1 /* alloc */)) == 0)
1790       return -1;
1791     if(*pte & PTE_P)
1792       panic("remap");
1793     *pte = pa | perm | PTE_P;
1794     if(a == last)
1795       break;
1796     a += PGSIZE;
1797     pa += PGSIZE;
1798   }
1799   return 0;
1800 }
1801 
1802 
1803 
1804 
1805 
1806 
1807 
1808 
1809 
1810 
1811 
1812 
1813 
1814 
1815 
1816 
1817 
1818 
1819 
1820 
1821 
1822 
1823 
1824 
1825 static struct kmap {
1826   void *virt;
1827   uint phys_start;
1828   uint phys_end;
1829   int perm;
1830 } kmap[] = {
1831  { (void*)KERNBASE, 0,             EXTMEM,    PTE_W}, 
1832  { (void*)KERNLINK, V2P(KERNLINK), V2P(data), 0},     
1833  { (void*)data,     V2P(data),     PHYSTOP,   PTE_W}, 
1834  { (void*)DEVSPACE, DEVSPACE,      0,         PTE_W}, 
1835 };
1836 
1837 
1838 
1839 
1840 
1841 
1842 
1843 
1844 
1845 
1846 
1847 
1848 
1849 
1850 
1851 pde_t*
1852 setupkvm(void)
1853 {
1854   pde_t *pgdir;
1855   struct kmap *k;
1856 
1857   
1858   
1859   if((pgdir = (pde_t*)kalloc()) == 0)
1860     return 0;
1861   memset(pgdir, 0, PGSIZE);
1862   if (P2V(PHYSTOP) > (void*)DEVSPACE)
1863     panic("PHYSTOP too high");
1864 
1865   
1866   for(k = kmap; k < &kmap[NELEM(kmap)]; k++)
1867     
1868     
1869     if(mappages(pgdir, k->virt, k->phys_end - k->phys_start,
1870                 (uint)k->phys_start, k->perm) < 0)
1871       return 0;
1872   return pgdir;
1873 }
1874 
1875 
1876 
1877 void
1878 kvmalloc(void)
1879 {
1880   kpgdir = setupkvm();
1881   switchkvm();
1882 }
1883 
1884 
1885 
1886 void
1887 switchkvm(void)
1888 {
1889   lcr3(V2P(kpgdir));   
1890 }
1891 
1892 
1893 
1894 
1895 
1896 
1897 
1898 
1899 
1900 
1901 void
1902 switchuvm(struct proc *p)
1903 {
1904   if(p == 0)
1905     panic("switchuvm: no process");
1906   if(p->kstack == 0)
1907     panic("switchuvm: no kstack");
1908   if(p->pgdir == 0)
1909     panic("switchuvm: no pgdir");
1910 
1911   pushcli();
1912   cpu->gdt[SEG_TSS] = SEG16(STS_T32A, &cpu->ts, sizeof(cpu->ts)-1, 0);
1913   cpu->gdt[SEG_TSS].s = 0;
1914   cpu->ts.ss0 = SEG_KDATA << 3;
1915   cpu->ts.esp0 = (uint)p->kstack + KSTACKSIZE;
1916   
1917   
1918   cpu->ts.iomb = (ushort) 0xFFFF;
1919   ltr(SEG_TSS << 3);
1920   lcr3(V2P(p->pgdir));  
1921   popcli();
1922 }
1923 
1924 
1925 
1926 void
1927 inituvm(pde_t *pgdir, char *init, uint sz)
1928 {
1929   char *mem;
1930 
1931   if(sz >= PGSIZE)
1932     panic("inituvm: more than a page");
1933   mem = kalloc();
1934   memset(mem, 0, PGSIZE);
1935   mappages(pgdir, 0, PGSIZE, V2P(mem), PTE_W|PTE_U);
1936   memmove(mem, init, sz);
1937 }
1938 
1939 
1940 
1941 
1942 
1943 
1944 
1945 
1946 
1947 
1948 
1949 
1950 
1951 
1952 int
1953 loaduvm(pde_t *pgdir, char *addr, struct inode *ip, uint offset, uint sz)
1954 {
1955   uint i, pa, n;
1956   pte_t *pte;
1957 
1958   if((uint) addr % PGSIZE != 0)
1959     panic("loaduvm: addr must be page aligned");
1960   for(i = 0; i < sz; i += PGSIZE){
1961     if((pte = walkpgdir(pgdir, addr+i, 0)) == 0)
1962       panic("loaduvm: address should exist");
1963     pa = PTE_ADDR(*pte);
1964     if(sz - i < PGSIZE)
1965       n = sz - i;
1966     else
1967       n = PGSIZE;
1968     if(readi(ip, P2V(pa), offset+i, n) != n)
1969       return -1;
1970   }
1971   return 0;
1972 }
1973 
1974 
1975 
1976 int
1977 allocuvm(pde_t *pgdir, uint oldsz, uint newsz)
1978 {
1979   char *mem;
1980   uint a;
1981 
1982   if(newsz >= KERNBASE)
1983     return 0;
1984   if(newsz < oldsz)
1985     return oldsz;
1986 
1987   a = PGROUNDUP(oldsz);
1988   for(; a < newsz; a += PGSIZE){
1989     mem = kalloc();
1990     if(mem == 0){
1991       cprintf("allocuvm out of memory\n");
1992       deallocuvm(pgdir, newsz, oldsz);
1993       return 0;
1994     }
1995     memset(mem, 0, PGSIZE);
1996     if(mappages(pgdir, (char*)a, PGSIZE, V2P(mem), PTE_W|PTE_U) < 0){
1997       cprintf("allocuvm out of memory (2)\n");
1998       deallocuvm(pgdir, newsz, oldsz);
1999       kfree(mem);
2000       return 0;
2001     }
2002   }
2003   return newsz;
2004 }
2005 
2006 
2007 
2008 
2009 
2010 int
2011 deallocuvm(pde_t *pgdir, uint oldsz, uint newsz)
2012 {
2013   pte_t *pte;
2014   uint a, pa;
2015 
2016   if(newsz >= oldsz)
2017     return oldsz;
2018 
2019   a = PGROUNDUP(newsz);
2020   for(; a  < oldsz; a += PGSIZE){
2021     pte = walkpgdir(pgdir, (char*)a, 0);
2022     if(!pte)
2023       a = PGADDR(PDX(a) + 1, 0, 0) - PGSIZE;
2024     else if((*pte & PTE_P) != 0){
2025       pa = PTE_ADDR(*pte);
2026       if(pa == 0)
2027         panic("kfree");
2028       char *v = P2V(pa);
2029       kfree(v);
2030       *pte = 0;
2031     }
2032   }
2033   return newsz;
2034 }
2035 
2036 
2037 
2038 
2039 
2040 
2041 
2042 
2043 
2044 
2045 
2046 
2047 
2048 
2049 
2050 
2051 
2052 void
2053 freevm(pde_t *pgdir)
2054 {
2055   uint i;
2056 
2057   if(pgdir == 0)
2058     panic("freevm: no pgdir");
2059   deallocuvm(pgdir, KERNBASE, 0);
2060   for(i = 0; i < NPDENTRIES; i++){
2061     if(pgdir[i] & PTE_P){
2062       char * v = P2V(PTE_ADDR(pgdir[i]));
2063       kfree(v);
2064     }
2065   }
2066   kfree((char*)pgdir);
2067 }
2068 
2069 
2070 
2071 void
2072 clearpteu(pde_t *pgdir, char *uva)
2073 {
2074   pte_t *pte;
2075 
2076   pte = walkpgdir(pgdir, uva, 0);
2077   if(pte == 0)
2078     panic("clearpteu");
2079   *pte &= ~PTE_U;
2080 }
2081 
2082 
2083 
2084 pde_t*
2085 copyuvm(pde_t *pgdir, uint sz)
2086 {
2087   pde_t *d;
2088   pte_t *pte;
2089   uint pa, i, flags;
2090   char *mem;
2091 
2092   if((d = setupkvm()) == 0)
2093     return 0;
2094   for(i = 0; i < sz; i += PGSIZE){
2095     if((pte = walkpgdir(pgdir, (void *) i, 0)) == 0)
2096       panic("copyuvm: pte should exist");
2097     if(!(*pte & PTE_P))
2098       panic("copyuvm: page not present");
2099     pa = PTE_ADDR(*pte);
2100     flags = PTE_FLAGS(*pte);
2101     if((mem = kalloc()) == 0)
2102       goto bad;
2103     memmove(mem, (char*)P2V(pa), PGSIZE);
2104     if(mappages(d, (void*)i, PGSIZE, V2P(mem), flags) < 0)
2105       goto bad;
2106   }
2107   return d;
2108 
2109 bad:
2110   freevm(d);
2111   return 0;
2112 }
2113 
2114 
2115 
2116 
2117 
2118 
2119 
2120 
2121 
2122 
2123 
2124 
2125 
2126 
2127 
2128 
2129 
2130 
2131 
2132 
2133 
2134 
2135 
2136 
2137 
2138 
2139 
2140 
2141 
2142 
2143 
2144 
2145 
2146 
2147 
2148 
2149 
2150 
2151 char*
2152 uva2ka(pde_t *pgdir, char *uva)
2153 {
2154   pte_t *pte;
2155 
2156   pte = walkpgdir(pgdir, uva, 0);
2157   if((*pte & PTE_P) == 0)
2158     return 0;
2159   if((*pte & PTE_U) == 0)
2160     return 0;
2161   return (char*)P2V(PTE_ADDR(*pte));
2162 }
2163 
2164 
2165 
2166 
2167 int
2168 copyout(pde_t *pgdir, uint va, void *p, uint len)
2169 {
2170   char *buf, *pa0;
2171   uint n, va0;
2172 
2173   buf = (char*)p;
2174   while(len > 0){
2175     va0 = (uint)PGROUNDDOWN(va);
2176     pa0 = uva2ka(pgdir, (char*)va0);
2177     if(pa0 == 0)
2178       return -1;
2179     n = PGSIZE - (va - va0);
2180     if(n > len)
2181       n = len;
2182     memmove(pa0 + (va - va0), buf, n);
2183     len -= n;
2184     buf += n;
2185     va = va0 + PGSIZE;
2186   }
2187   return 0;
2188 }
2189 
2190 
2191 
2192 
2193 
2194 
2195 
2196 
2197 
2198 
2199 
2200 
2201 
2202 
2203 
2204 
2205 
2206 
2207 
2208 
2209 
2210 
2211 
2212 
2213 
2214 
2215 
2216 
2217 
2218 
2219 
2220 
2221 
2222 
2223 
2224 
2225 
2226 
2227 
2228 
2229 
2230 
2231 
2232 
2233 
2234 
2235 
2236 
2237 
2238 
2239 
2240 
2241 
2242 
2243 
2244 
2245 
2246 
2247 
2248 
2249 
2250 
2251 
2252 
2253 
2254 
2255 
2256 
2257 
2258 
2259 
2260 
2261 
2262 
2263 
2264 
2265 
2266 
2267 
2268 
2269 
2270 
2271 
2272 
2273 
2274 
2275 
2276 
2277 
2278 
2279 
2280 
2281 
2282 
2283 
2284 
2285 
2286 
2287 
2288 
2289 
2290 
2291 
2292 
2293 
2294 
2295 
2296 
2297 
2298 
2299 
2300 
2301 
2302 
2303 
2304 
2305 
2306 
2307 
2308 
2309 
2310 
2311 
2312 
2313 
2314 
2315 
2316 
2317 
2318 
2319 
2320 
2321 
2322 
2323 
2324 
2325 
2326 
2327 
2328 
2329 
2330 
2331 
2332 
2333 
2334 
2335 
2336 
2337 
2338 
2339 
2340 
2341 
2342 
2343 
2344 
2345 
2346 
2347 
2348 
2349 
2350 
2351 struct cpu {
2352   uchar apicid;                
2353   struct context *scheduler;   
2354   struct taskstate ts;         
2355   struct segdesc gdt[NSEGS];   
2356   volatile uint started;       
2357   int ncli;                    
2358   int intena;                  
2359 
2360   
2361   struct cpu *cpu;
2362   struct proc *proc;           
2363 };
2364 
2365 extern struct cpu cpus[NCPU];
2366 extern int ncpu;
2367 
2368 
2369 
2370 
2371 
2372 
2373 
2374 
2375 
2376 extern struct cpu *cpu asm("%gs:0");       
2377 extern struct proc *proc asm("%gs:4");     
2378 
2379 
2380 
2381 
2382 
2383 
2384 
2385 
2386 
2387 
2388 
2389 
2390 struct context {
2391   uint edi;
2392   uint esi;
2393   uint ebx;
2394   uint ebp;
2395   uint eip;
2396 };
2397 
2398 
2399 
2400 enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };
2401 
2402 
2403 struct proc {
2404   uint sz;                     
2405   pde_t* pgdir;                
2406   char *kstack;                
2407   enum procstate state;        
2408   int pid;                     
2409   struct proc *parent;         
2410   struct trapframe *tf;        
2411   struct context *context;     
2412   void *chan;                  
2413   int killed;                  
2414   struct file *ofile[NOFILE];  
2415   struct inode *cwd;           
2416   char name[16];               
2417 };
2418 
2419 
2420 
2421 
2422 
2423 
2424 
2425 
2426 
2427 
2428 
2429 
2430 
2431 
2432 
2433 
2434 
2435 
2436 
2437 
2438 
2439 
2440 
2441 
2442 
2443 
2444 
2445 
2446 
2447 
2448 
2449 
2450 #include "types.h"
2451 #include "defs.h"
2452 #include "param.h"
2453 #include "memlayout.h"
2454 #include "mmu.h"
2455 #include "x86.h"
2456 #include "proc.h"
2457 #include "spinlock.h"
2458 
2459 struct {
2460   struct spinlock lock;
2461   struct proc proc[NPROC];
2462 } ptable;
2463 
2464 static struct proc *initproc;
2465 
2466 int nextpid = 1;
2467 extern void forkret(void);
2468 extern void trapret(void);
2469 
2470 static void wakeup1(void *chan);
2471 
2472 void
2473 pinit(void)
2474 {
2475   initlock(&ptable.lock, "ptable");
2476 }
2477 
2478 
2479 
2480 
2481 
2482 
2483 
2484 
2485 
2486 
2487 
2488 
2489 
2490 
2491 
2492 
2493 
2494 
2495 
2496 
2497 
2498 
2499 
2500 
2501 
2502 
2503 
2504 static struct proc*
2505 allocproc(void)
2506 {
2507   struct proc *p;
2508   char *sp;
2509 
2510   acquire(&ptable.lock);
2511 
2512   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
2513     if(p->state == UNUSED)
2514       goto found;
2515 
2516   release(&ptable.lock);
2517   return 0;
2518 
2519 found:
2520   p->state = EMBRYO;
2521   p->pid = nextpid++;
2522 
2523   release(&ptable.lock);
2524 
2525   
2526   if((p->kstack = kalloc()) == 0){
2527     p->state = UNUSED;
2528     return 0;
2529   }
2530   sp = p->kstack + KSTACKSIZE;
2531 
2532   
2533   sp -= sizeof *p->tf;
2534   p->tf = (struct trapframe*)sp;
2535 
2536   
2537   
2538   sp -= 4;
2539   *(uint*)sp = (uint)trapret;
2540 
2541   sp -= sizeof *p->context;
2542   p->context = (struct context*)sp;
2543   memset(p->context, 0, sizeof *p->context);
2544   p->context->eip = (uint)forkret;
2545 
2546   return p;
2547 }
2548 
2549 
2550 
2551 void
2552 userinit(void)
2553 {
2554   struct proc *p;
2555   extern char _binary_initcode_start[], _binary_initcode_size[];
2556 
2557   p = allocproc();
2558 
2559   initproc = p;
2560   if((p->pgdir = setupkvm()) == 0)
2561     panic("userinit: out of memory?");
2562   inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
2563   p->sz = PGSIZE;
2564   memset(p->tf, 0, sizeof(*p->tf));
2565   p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
2566   p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
2567   p->tf->es = p->tf->ds;
2568   p->tf->ss = p->tf->ds;
2569   p->tf->eflags = FL_IF;
2570   p->tf->esp = PGSIZE;
2571   p->tf->eip = 0;  
2572 
2573   safestrcpy(p->name, "initcode", sizeof(p->name));
2574   p->cwd = namei("/");
2575 
2576   
2577   
2578   
2579   
2580   acquire(&ptable.lock);
2581 
2582   p->state = RUNNABLE;
2583 
2584   release(&ptable.lock);
2585 }
2586 
2587 
2588 
2589 
2590 
2591 
2592 
2593 
2594 
2595 
2596 
2597 
2598 
2599 
2600 
2601 
2602 int
2603 growproc(int n)
2604 {
2605   uint sz;
2606 
2607   sz = proc->sz;
2608   if(n > 0){
2609     if((sz = allocuvm(proc->pgdir, sz, sz + n)) == 0)
2610       return -1;
2611   } else if(n < 0){
2612     if((sz = deallocuvm(proc->pgdir, sz, sz + n)) == 0)
2613       return -1;
2614   }
2615   proc->sz = sz;
2616   switchuvm(proc);
2617   return 0;
2618 }
2619 
2620 
2621 
2622 
2623 int
2624 fork(void)
2625 {
2626   int i, pid;
2627   struct proc *np;
2628 
2629   
2630   if((np = allocproc()) == 0){
2631     return -1;
2632   }
2633 
2634   
2635   if((np->pgdir = copyuvm(proc->pgdir, proc->sz)) == 0){
2636     kfree(np->kstack);
2637     np->kstack = 0;
2638     np->state = UNUSED;
2639     return -1;
2640   }
2641   np->sz = proc->sz;
2642   np->parent = proc;
2643   *np->tf = *proc->tf;
2644 
2645   
2646   np->tf->eax = 0;
2647 
2648 
2649 
2650   for(i = 0; i < NOFILE; i++)
2651     if(proc->ofile[i])
2652       np->ofile[i] = filedup(proc->ofile[i]);
2653   np->cwd = idup(proc->cwd);
2654 
2655   safestrcpy(np->name, proc->name, sizeof(proc->name));
2656 
2657   pid = np->pid;
2658 
2659   acquire(&ptable.lock);
2660 
2661   np->state = RUNNABLE;
2662 
2663   release(&ptable.lock);
2664 
2665   return pid;
2666 }
2667 
2668 
2669 
2670 
2671 void
2672 exit(void)
2673 {
2674   struct proc *p;
2675   int fd;
2676 
2677   if(proc == initproc)
2678     panic("init exiting");
2679 
2680   
2681   for(fd = 0; fd < NOFILE; fd++){
2682     if(proc->ofile[fd]){
2683       fileclose(proc->ofile[fd]);
2684       proc->ofile[fd] = 0;
2685     }
2686   }
2687 
2688   begin_op();
2689   iput(proc->cwd);
2690   end_op();
2691   proc->cwd = 0;
2692 
2693   acquire(&ptable.lock);
2694 
2695   
2696   wakeup1(proc->parent);
2697 
2698 
2699 
2700   
2701   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
2702     if(p->parent == proc){
2703       p->parent = initproc;
2704       if(p->state == ZOMBIE)
2705         wakeup1(initproc);
2706     }
2707   }
2708 
2709   
2710   proc->state = ZOMBIE;
2711   sched();
2712   panic("zombie exit");
2713 }
2714 
2715 
2716 
2717 int
2718 wait(void)
2719 {
2720   struct proc *p;
2721   int havekids, pid;
2722 
2723   acquire(&ptable.lock);
2724   for(;;){
2725     
2726     havekids = 0;
2727     for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
2728       if(p->parent != proc)
2729         continue;
2730       havekids = 1;
2731       if(p->state == ZOMBIE){
2732         
2733         pid = p->pid;
2734         kfree(p->kstack);
2735         p->kstack = 0;
2736         freevm(p->pgdir);
2737         p->pid = 0;
2738         p->parent = 0;
2739         p->name[0] = 0;
2740         p->killed = 0;
2741         p->state = UNUSED;
2742         release(&ptable.lock);
2743         return pid;
2744       }
2745     }
2746 
2747 
2748 
2749 
2750     
2751     if(!havekids || proc->killed){
2752       release(&ptable.lock);
2753       return -1;
2754     }
2755 
2756     
2757     sleep(proc, &ptable.lock);  
2758   }
2759 }
2760 
2761 
2762 
2763 
2764 
2765 
2766 
2767 
2768 
2769 
2770 
2771 
2772 
2773 
2774 
2775 
2776 
2777 
2778 
2779 
2780 
2781 
2782 
2783 
2784 
2785 
2786 
2787 
2788 
2789 
2790 
2791 
2792 
2793 
2794 
2795 
2796 
2797 
2798 
2799 
2800 
2801 
2802 
2803 
2804 
2805 
2806 
2807 void
2808 scheduler(void)
2809 {
2810   struct proc *p;
2811 
2812   for(;;){
2813     
2814     sti();
2815 
2816     
2817     acquire(&ptable.lock);
2818     for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
2819       if(p->state != RUNNABLE)
2820         continue;
2821 
2822       
2823       
2824       
2825       proc = p;
2826       switchuvm(p);
2827       p->state = RUNNING;
2828       swtch(&cpu->scheduler, p->context);
2829       switchkvm();
2830 
2831       
2832       
2833       proc = 0;
2834     }
2835     release(&ptable.lock);
2836 
2837   }
2838 }
2839 
2840 
2841 
2842 
2843 
2844 
2845 
2846 
2847 
2848 
2849 
2850 
2851 
2852 
2853 
2854 
2855 
2856 
2857 void
2858 sched(void)
2859 {
2860   int intena;
2861 
2862   if(!holding(&ptable.lock))
2863     panic("sched ptable.lock");
2864   if(cpu->ncli != 1)
2865     panic("sched locks");
2866   if(proc->state == RUNNING)
2867     panic("sched running");
2868   if(readeflags()&FL_IF)
2869     panic("sched interruptible");
2870   intena = cpu->intena;
2871   swtch(&proc->context, cpu->scheduler);
2872   cpu->intena = intena;
2873 }
2874 
2875 
2876 void
2877 yield(void)
2878 {
2879   acquire(&ptable.lock);  
2880   proc->state = RUNNABLE;
2881   sched();
2882   release(&ptable.lock);
2883 }
2884 
2885 
2886 
2887 void
2888 forkret(void)
2889 {
2890   static int first = 1;
2891   
2892   release(&ptable.lock);
2893 
2894   if (first) {
2895     
2896     
2897     
2898     first = 0;
2899     iinit(ROOTDEV);
2900     initlog(ROOTDEV);
2901   }
2902 
2903   
2904 }
2905 
2906 
2907 
2908 void
2909 sleep(void *chan, struct spinlock *lk)
2910 {
2911   if(proc == 0)
2912     panic("sleep");
2913 
2914   if(lk == 0)
2915     panic("sleep without lk");
2916 
2917   
2918   
2919   
2920   
2921   
2922   
2923   if(lk != &ptable.lock){  
2924     acquire(&ptable.lock);  
2925     release(lk);
2926   }
2927 
2928   
2929   proc->chan = chan;
2930   proc->state = SLEEPING;
2931   sched();
2932 
2933   
2934   proc->chan = 0;
2935 
2936   
2937   if(lk != &ptable.lock){  
2938     release(&ptable.lock);
2939     acquire(lk);
2940   }
2941 }
2942 
2943 
2944 
2945 
2946 
2947 
2948 
2949 
2950 
2951 
2952 static void
2953 wakeup1(void *chan)
2954 {
2955   struct proc *p;
2956 
2957   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
2958     if(p->state == SLEEPING && p->chan == chan)
2959       p->state = RUNNABLE;
2960 }
2961 
2962 
2963 void
2964 wakeup(void *chan)
2965 {
2966   acquire(&ptable.lock);
2967   wakeup1(chan);
2968   release(&ptable.lock);
2969 }
2970 
2971 
2972 
2973 
2974 int
2975 kill(int pid)
2976 {
2977   struct proc *p;
2978 
2979   acquire(&ptable.lock);
2980   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
2981     if(p->pid == pid){
2982       p->killed = 1;
2983       
2984       if(p->state == SLEEPING)
2985         p->state = RUNNABLE;
2986       release(&ptable.lock);
2987       return 0;
2988     }
2989   }
2990   release(&ptable.lock);
2991   return -1;
2992 }
2993 
2994 
2995 
2996 
2997 
2998 
2999 
3000 
3001 
3002 
3003 void
3004 procdump(void)
3005 {
3006   static char *states[] = {
3007   [UNUSED]    "unused",
3008   [EMBRYO]    "embryo",
3009   [SLEEPING]  "sleep ",
3010   [RUNNABLE]  "runble",
3011   [RUNNING]   "run   ",
3012   [ZOMBIE]    "zombie"
3013   };
3014   int i;
3015   struct proc *p;
3016   char *state;
3017   uint pc[10];
3018 
3019   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
3020     if(p->state == UNUSED)
3021       continue;
3022     if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
3023       state = states[p->state];
3024     else
3025       state = "???";
3026     cprintf("%d %s %s", p->pid, state, p->name);
3027     if(p->state == SLEEPING){
3028       getcallerpcs((uint*)p->context->ebp+2, pc);
3029       for(i=0; i<10 && pc[i] != 0; i++)
3030         cprintf(" %p", pc[i]);
3031     }
3032     cprintf("\n");
3033   }
3034 }
3035 
3036 
3037 
3038 
3039 
3040 
3041 
3042 
3043 
3044 
3045 
3046 
3047 
3048 
3049 
3050 
3051 
3052 
3053 
3054 
3055 
3056 
3057 .globl swtch
3058 swtch:
3059   movl 4(%esp), %eax
3060   movl 8(%esp), %edx
3061 
3062   
3063   pushl %ebp
3064   pushl %ebx
3065   pushl %esi
3066   pushl %edi
3067 
3068   
3069   movl %esp, (%eax)
3070   movl %edx, %esp
3071 
3072   
3073   popl %edi
3074   popl %esi
3075   popl %ebx
3076   popl %ebp
3077   ret
3078 
3079 
3080 
3081 
3082 
3083 
3084 
3085 
3086 
3087 
3088 
3089 
3090 
3091 
3092 
3093 
3094 
3095 
3096 
3097 
3098 
3099 
3100 
3101 
3102 
3103 
3104 #include "types.h"
3105 #include "defs.h"
3106 #include "param.h"
3107 #include "memlayout.h"
3108 #include "mmu.h"
3109 #include "spinlock.h"
3110 
3111 void freerange(void *vstart, void *vend);
3112 extern char end[]; 
3113 
3114 
3115 
3116 
3117 
3118 struct run {
3119   struct run *next;
3120 };
3121 
3122 struct {
3123   struct spinlock lock;
3124   int use_lock;
3125   struct run *freelist;
3126 } kmem;
3127 
3128 
3129 
3130 
3131 
3132 
3133 
3134 
3135 
3136 void
3137 kinit1(void *vstart, void *vend)
3138 {
3139   initlock(&kmem.lock, "kmem");
3140   kmem.use_lock = 0;
3141   freerange(vstart, vend);
3142 }
3143 
3144 void
3145 kinit2(void *vstart, void *vend)
3146 {
3147   freerange(vstart, vend);
3148   kmem.use_lock = 1;
3149 }
3150 void
3151 freerange(void *vstart, void *vend)
3152 {
3153   char *p;
3154   p = (char*)PGROUNDUP((uint)vstart);
3155   for(; p + PGSIZE <= (char*)vend; p += PGSIZE)
3156     kfree(p);
3157 }
3158 
3159 
3160 
3161 
3162 
3163 
3164 void
3165 kfree(char *v)
3166 {
3167   struct run *r;
3168 
3169   if((uint)v % PGSIZE || v < end || V2P(v) >= PHYSTOP)
3170     panic("kfree");
3171 
3172   
3173   memset(v, 1, PGSIZE);
3174 
3175   if(kmem.use_lock)
3176     acquire(&kmem.lock);
3177   r = (struct run*)v;
3178   r->next = kmem.freelist;
3179   kmem.freelist = r;
3180   if(kmem.use_lock)
3181     release(&kmem.lock);
3182 }
3183 
3184 
3185 
3186 
3187 
3188 char*
3189 kalloc(void)
3190 {
3191   struct run *r;
3192 
3193   if(kmem.use_lock)
3194     acquire(&kmem.lock);
3195   r = kmem.freelist;
3196   if(r)
3197     kmem.freelist = r->next;
3198   if(kmem.use_lock)
3199     release(&kmem.lock);
3200   return (char*)r;
3201 }
3202 
3203 
3204 
3205 
3206 
3207 
3208 
3209 
3210 
3211 
3212 
3213 
3214 
3215 
3216 
3217 
3218 
3219 
3220 
3221 
3222 
3223 
3224 
3225 
3226 
3227 
3228 
3229 
3230 
3231 
3232 
3233 
3234 
3235 
3236 
3237 
3238 
3239 
3240 
3241 
3242 
3243 
3244 
3245 
3246 
3247 
3248 
3249 
3250 
3251 
3252 
3253 #define T_DIVIDE         0      
3254 #define T_DEBUG          1      
3255 #define T_NMI            2      
3256 #define T_BRKPT          3      
3257 #define T_OFLOW          4      
3258 #define T_BOUND          5      
3259 #define T_ILLOP          6      
3260 #define T_DEVICE         7      
3261 #define T_DBLFLT         8      
3262 
3263 #define T_TSS           10      
3264 #define T_SEGNP         11      
3265 #define T_STACK         12      
3266 #define T_GPFLT         13      
3267 #define T_PGFLT         14      
3268 
3269 #define T_FPERR         16      
3270 #define T_ALIGN         17      
3271 #define T_MCHK          18      
3272 #define T_SIMDERR       19      
3273 
3274 
3275 
3276 #define T_SYSCALL       64      
3277 #define T_DEFAULT      500      
3278 
3279 #define T_IRQ0          32      
3280 
3281 #define IRQ_TIMER        0
3282 #define IRQ_KBD          1
3283 #define IRQ_COM1         4
3284 #define IRQ_IDE         14
3285 #define IRQ_ERROR       19
3286 #define IRQ_SPURIOUS    31
3287 
3288 
3289 
3290 
3291 
3292 
3293 
3294 
3295 
3296 
3297 
3298 
3299 
3300 #!/usr/bin/perl -w
3301 
3302 # Generate vectors.S, the trap/interrupt entry points.
3303 # There has to be one entry point per interrupt number
3304 # since otherwise there's no way for trap() to discover
3305 # the interrupt number.
3306 
3307 print "# generated by vectors.pl - do not edit\n";
3308 print "# handlers\n";
3309 print ".globl alltraps\n";
3310 for(my $i = 0; $i < 256; $i++){
3311     print ".globl vector$i\n";
3312     print "vector$i:\n";
3313     if(!($i == 8 || ($i >= 10 && $i <= 14) || $i == 17)){
3314         print "  pushl \$0\n";
3315     }
3316     print "  pushl \$$i\n";
3317     print "  jmp alltraps\n";
3318 }
3319 
3320 print "\n# vector table\n";
3321 print ".data\n";
3322 print ".globl vectors\n";
3323 print "vectors:\n";
3324 for(my $i = 0; $i < 256; $i++){
3325     print "  .long vector$i\n";
3326 }
3327 
3328 # sample output:
3329 #   # handlers
3330 #   .globl alltraps
3331 #   .globl vector0
3332 #   vector0:
3333 #     pushl $0
3334 #     pushl $0
3335 #     jmp alltraps
3336 #   ...
3337 #
3338 #   # vector table
3339 #   .data
3340 #   .globl vectors
3341 #   vectors:
3342 #     .long vector0
3343 #     .long vector1
3344 #     .long vector2
3345 #   ...
3346 
3347 
3348 
3349 
3350 
3351 
3352   
3353 .globl alltraps
3354 alltraps:
3355   
3356   pushl %ds
3357   pushl %es
3358   pushl %fs
3359   pushl %gs
3360   pushal
3361 
3362   
3363   movw $(SEG_KDATA<<3), %ax
3364   movw %ax, %ds
3365   movw %ax, %es
3366   movw $(SEG_KCPU<<3), %ax
3367   movw %ax, %fs
3368   movw %ax, %gs
3369 
3370   
3371   pushl %esp
3372   call trap
3373   addl $4, %esp
3374 
3375   
3376 .globl trapret
3377 trapret:
3378   popal
3379   popl %gs
3380   popl %fs
3381   popl %es
3382   popl %ds
3383   addl $0x8, %esp  
3384   iret
3385 
3386 
3387 
3388 
3389 
3390 
3391 
3392 
3393 
3394 
3395 
3396 
3397 
3398 
3399 
3400 #include "types.h"
3401 #include "defs.h"
3402 #include "param.h"
3403 #include "memlayout.h"
3404 #include "mmu.h"
3405 #include "proc.h"
3406 #include "x86.h"
3407 #include "traps.h"
3408 #include "spinlock.h"
3409 
3410 
3411 struct gatedesc idt[256];
3412 extern uint vectors[];  
3413 struct spinlock tickslock;
3414 uint ticks;
3415 
3416 void
3417 tvinit(void)
3418 {
3419   int i;
3420 
3421   for(i = 0; i < 256; i++)
3422     SETGATE(idt[i], 0, SEG_KCODE<<3, vectors[i], 0);
3423 
3424   
3425   
3426   
3427   
3428   
3429   
3430   
3431   
3432   
3433   SETGATE(idt[T_SYSCALL], 1, SEG_KCODE<<3, vectors[T_SYSCALL], DPL_USER);
3434 
3435   initlock(&tickslock, "time");
3436 }
3437 
3438 void
3439 idtinit(void)
3440 {
3441   lidt(idt, sizeof(idt));
3442 }
3443 
3444 
3445 
3446 
3447 
3448 
3449 
3450 void
3451 trap(struct trapframe *tf)
3452 {
3453   if(tf->trapno == T_SYSCALL){
3454     if(proc->killed)
3455       exit();
3456     proc->tf = tf;
3457     syscall();
3458     if(proc->killed)
3459       exit();
3460     return;
3461   }
3462 
3463   switch(tf->trapno){
3464   case T_IRQ0 + IRQ_TIMER:
3465     if(cpunum() == 0){
3466       acquire(&tickslock);
3467       ticks++;
3468       wakeup(&ticks);
3469       release(&tickslock);
3470     }
3471     lapiceoi();
3472     break;
3473   case T_IRQ0 + IRQ_IDE:
3474     ideintr();
3475     lapiceoi();
3476     break;
3477   case T_IRQ0 + IRQ_IDE+1:
3478     
3479     break;
3480   case T_IRQ0 + IRQ_KBD:
3481     kbdintr();
3482     lapiceoi();
3483     break;
3484   case T_IRQ0 + IRQ_COM1:
3485     uartintr();
3486     lapiceoi();
3487     break;
3488   case T_IRQ0 + 7:
3489   case T_IRQ0 + IRQ_SPURIOUS:
3490     cprintf("cpu%d: spurious interrupt at %x:%x\n",
3491             cpunum(), tf->cs, tf->eip);
3492     lapiceoi();
3493     break;
3494 
3495 
3496 
3497 
3498 
3499 
3500   default:
3501     if(proc == 0 || (tf->cs&3) == 0){
3502       
3503       cprintf("unexpected trap %d from cpu %d eip %x (cr2=0x%x)\n",
3504               tf->trapno, cpunum(), tf->eip, rcr2());
3505       panic("trap");
3506     }
3507     
3508     cprintf("pid %d %s: trap %d err %d on cpu %d "
3509             "eip 0x%x addr 0x%x--kill proc\n",
3510             proc->pid, proc->name, tf->trapno, tf->err, cpunum(), tf->eip,
3511             rcr2());
3512     proc->killed = 1;
3513   }
3514 
3515   
3516   
3517   
3518   if(proc && proc->killed && (tf->cs&3) == DPL_USER)
3519     exit();
3520 
3521   
3522   
3523   if(proc && proc->state == RUNNING && tf->trapno == T_IRQ0+IRQ_TIMER)
3524     yield();
3525 
3526   
3527   if(proc && proc->killed && (tf->cs&3) == DPL_USER)
3528     exit();
3529 }
3530 
3531 
3532 
3533 
3534 
3535 
3536 
3537 
3538 
3539 
3540 
3541 
3542 
3543 
3544 
3545 
3546 
3547 
3548 
3549 
3550 
3551 #define SYS_fork    1
3552 #define SYS_exit    2
3553 #define SYS_wait    3
3554 #define SYS_pipe    4
3555 #define SYS_read    5
3556 #define SYS_kill    6
3557 #define SYS_exec    7
3558 #define SYS_fstat   8
3559 #define SYS_chdir   9
3560 #define SYS_dup    10
3561 #define SYS_getpid 11
3562 #define SYS_sbrk   12
3563 #define SYS_sleep  13
3564 #define SYS_uptime 14
3565 #define SYS_open   15
3566 #define SYS_write  16
3567 #define SYS_mknod  17
3568 #define SYS_unlink 18
3569 #define SYS_link   19
3570 #define SYS_mkdir  20
3571 #define SYS_close  21
3572 #define SYS_date   22
3573 
3574 
3575 
3576 
3577 
3578 
3579 
3580 
3581 
3582 
3583 
3584 
3585 
3586 
3587 
3588 
3589 
3590 
3591 
3592 
3593 
3594 
3595 
3596 
3597 
3598 
3599 
3600 #include "types.h"
3601 #include "defs.h"
3602 #include "param.h"
3603 #include "memlayout.h"
3604 #include "mmu.h"
3605 #include "proc.h"
3606 #include "x86.h"
3607 #include "syscall.h"
3608 
3609 
3610 
3611 
3612 
3613 
3614 
3615 
3616 int
3617 fetchint(uint addr, int *ip)
3618 {
3619   if(addr >= proc->sz || addr+4 > proc->sz)
3620     return -1;
3621   *ip = *(int*)(addr);
3622   return 0;
3623 }
3624 
3625 
3626 
3627 
3628 int
3629 fetchstr(uint addr, char **pp)
3630 {
3631   char *s, *ep;
3632 
3633   if(addr >= proc->sz)
3634     return -1;
3635   *pp = (char*)addr;
3636   ep = (char*)proc->sz;
3637   for(s = *pp; s < ep; s++)
3638     if(*s == 0)
3639       return s - *pp;
3640   return -1;
3641 }
3642 
3643 
3644 int
3645 argint(int n, int *ip)
3646 {
3647   return fetchint(proc->tf->esp + 4 + 4*n, ip);
3648 }
3649 
3650 
3651 
3652 
3653 int
3654 argptr(int n, char **pp, int size)
3655 {
3656   int i;
3657 
3658   if(argint(n, &i) < 0)
3659     return -1;
3660   if(size < 0 || (uint)i >= proc->sz || (uint)i+size > proc->sz)
3661     return -1;
3662   *pp = (char*)i;
3663   return 0;
3664 }
3665 
3666 
3667 
3668 
3669 
3670 int
3671 argstr(int n, char **pp)
3672 {
3673   int addr;
3674   if(argint(n, &addr) < 0)
3675     return -1;
3676   return fetchstr(addr, pp);
3677 }
3678 
3679 extern int sys_chdir(void);
3680 extern int sys_close(void);
3681 extern int sys_dup(void);
3682 extern int sys_exec(void);
3683 extern int sys_exit(void);
3684 extern int sys_fork(void);
3685 extern int sys_fstat(void);
3686 extern int sys_getpid(void);
3687 extern int sys_kill(void);
3688 extern int sys_link(void);
3689 extern int sys_mkdir(void);
3690 extern int sys_mknod(void);
3691 extern int sys_open(void);
3692 extern int sys_pipe(void);
3693 extern int sys_read(void);
3694 extern int sys_sbrk(void);
3695 extern int sys_sleep(void);
3696 extern int sys_unlink(void);
3697 extern int sys_wait(void);
3698 extern int sys_write(void);
3699 extern int sys_uptime(void);
3700 extern int sys_date(void);
3701 
3702 static int (*syscalls[])(void) = {
3703 [SYS_fork]    sys_fork,
3704 [SYS_exit]    sys_exit,
3705 [SYS_wait]    sys_wait,
3706 [SYS_pipe]    sys_pipe,
3707 [SYS_read]    sys_read,
3708 [SYS_kill]    sys_kill,
3709 [SYS_exec]    sys_exec,
3710 [SYS_fstat]   sys_fstat,
3711 [SYS_chdir]   sys_chdir,
3712 [SYS_dup]     sys_dup,
3713 [SYS_getpid]  sys_getpid,
3714 [SYS_sbrk]    sys_sbrk,
3715 [SYS_sleep]   sys_sleep,
3716 [SYS_uptime]  sys_uptime,
3717 [SYS_open]    sys_open,
3718 [SYS_write]   sys_write,
3719 [SYS_mknod]   sys_mknod,
3720 [SYS_unlink]  sys_unlink,
3721 [SYS_link]    sys_link,
3722 [SYS_mkdir]   sys_mkdir,
3723 [SYS_close]   sys_close,
3724 [SYS_date]  sys_date,
3725 };
3726 
3727 char * get_syscall_name(int num) {
3728   switch (num) {
3729     case SYS_fork:
3730       return "fork";
3731     case SYS_exit:
3732       return "exit";
3733     case SYS_wait:
3734       return "wait";
3735     case SYS_pipe:
3736       return "pipe";
3737     case SYS_read:
3738       return "read";
3739     case SYS_kill:
3740       return "kill";
3741     case SYS_exec:
3742       return "exec";
3743     case SYS_fstat:
3744       return "fstat";
3745     case SYS_chdir:
3746       return "chdir";
3747     case SYS_dup:
3748       return "dup";
3749     case SYS_getpid:
3750       return "getpid";
3751     case SYS_sbrk:
3752       return "sbrk";
3753     case SYS_sleep:
3754       return "sleep";
3755     case SYS_uptime:
3756       return "uptime";
3757     case SYS_open:
3758       return "open";
3759     case SYS_write:
3760       return "write";
3761     case SYS_mknod:
3762       return "mknod";
3763     case SYS_unlink:
3764       return "unlink";
3765     case SYS_link:
3766       return "link";
3767     case SYS_mkdir:
3768       return "mkdir";
3769     case SYS_close:
3770       return "close";
3771     case SYS_date:
3772       return "date";
3773     default:
3774       return "unknown";
3775   }
3776 }
3777 
3778 void
3779 syscall(void)
3780 {
3781   int num;
3782 
3783   num = proc->tf->eax;
3784   if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
3785     proc->tf->eax = syscalls[num]();
3786     
3787     
3788   } else {
3789     cprintf("%d %s: unknown sys call %d\n",
3790             proc->pid, proc->name, num);
3791     proc->tf->eax = -1;
3792   }
3793 }
3794 
3795 
3796 
3797 
3798 
3799 
3800 #include "types.h"
3801 #include "x86.h"
3802 #include "defs.h"
3803 #include "date.h"
3804 #include "param.h"
3805 #include "memlayout.h"
3806 #include "mmu.h"
3807 #include "proc.h"
3808 
3809 int
3810 sys_fork(void)
3811 {
3812   return fork();
3813 }
3814 
3815 int
3816 sys_exit(void)
3817 {
3818   exit();
3819   return 0;  
3820 }
3821 
3822 int
3823 sys_wait(void)
3824 {
3825   return wait();
3826 }
3827 
3828 int
3829 sys_kill(void)
3830 {
3831   int pid;
3832 
3833   if(argint(0, &pid) < 0)
3834     return -1;
3835   return kill(pid);
3836 }
3837 
3838 int
3839 sys_getpid(void)
3840 {
3841   return proc->pid;
3842 }
3843 
3844 
3845 
3846 
3847 
3848 
3849 
3850 int
3851 sys_sbrk(void)
3852 {
3853   int addr;
3854   int n;
3855 
3856   if(argint(0, &n) < 0)
3857     return -1;
3858   addr = proc->sz;
3859   
3860   
3861   
3862   return addr;
3863 }
3864 
3865 int
3866 sys_sleep(void)
3867 {
3868   int n;
3869   uint ticks0;
3870 
3871   if(argint(0, &n) < 0)
3872     return -1;
3873   acquire(&tickslock);
3874   ticks0 = ticks;
3875   while(ticks - ticks0 < n){
3876     if(proc->killed){
3877       release(&tickslock);
3878       return -1;
3879     }
3880     sleep(&ticks, &tickslock);
3881   }
3882   release(&tickslock);
3883   return 0;
3884 }
3885 
3886 
3887 
3888 int
3889 sys_uptime(void)
3890 {
3891   uint xticks;
3892 
3893   acquire(&tickslock);
3894   xticks = ticks;
3895   release(&tickslock);
3896   return xticks;
3897 }
3898 
3899 
3900 int
3901 sys_date(void)
3902 {
3903   struct rtcdate *r;
3904 
3905   if(argptr(0, (char **)&r, sizeof(struct rtcdate)) < 0)
3906     return -1;
3907   cmostime(r);
3908   return 0;
3909 }
3910 
3911 
3912 
3913 
3914 
3915 
3916 
3917 
3918 
3919 
3920 
3921 
3922 
3923 
3924 
3925 
3926 
3927 
3928 
3929 
3930 
3931 
3932 
3933 
3934 
3935 
3936 
3937 
3938 
3939 
3940 
3941 
3942 
3943 
3944 
3945 
3946 
3947 
3948 
3949 
3950 
3951 
3952 
3953 
3954 
3955 
3956 struct buf {
3957   
3958   
3959   
3960   
3961   
3962   int flags;
3963   
3964   
3965   
3966   
3967   uint dev;
3968   uint blockno;
3969   struct sleeplock lock;
3970   uint refcnt;
3971   struct buf *prev; 
3972   struct buf *next;
3973   struct buf *qnext; 
3974   uchar data[BSIZE];
3975 };
3976 #define B_VALID 0x2  
3977 #define B_DIRTY 0x4  
3978 
3979 
3980 
3981 
3982 
3983 
3984 
3985 
3986 
3987 
3988 
3989 
3990 
3991 
3992 
3993 
3994 
3995 
3996 
3997 
3998 
3999 
4000 
4001 struct sleeplock {
4002   uint locked;       
4003   struct spinlock lk; 
4004 
4005   
4006   char *name;        
4007   int pid;           
4008 };
4009 
4010 
4011 
4012 
4013 
4014 
4015 
4016 
4017 
4018 
4019 
4020 
4021 
4022 
4023 
4024 
4025 
4026 
4027 
4028 
4029 
4030 
4031 
4032 
4033 
4034 
4035 
4036 
4037 
4038 
4039 
4040 
4041 
4042 
4043 
4044 
4045 
4046 
4047 
4048 
4049 
4050 #define O_RDONLY  0x000
4051 #define O_WRONLY  0x001
4052 #define O_RDWR    0x002
4053 #define O_CREATE  0x200
4054 
4055 
4056 
4057 
4058 
4059 
4060 
4061 
4062 
4063 
4064 
4065 
4066 
4067 
4068 
4069 
4070 
4071 
4072 
4073 
4074 
4075 
4076 
4077 
4078 
4079 
4080 
4081 
4082 
4083 
4084 
4085 
4086 
4087 
4088 
4089 
4090 
4091 
4092 
4093 
4094 
4095 
4096 
4097 
4098 
4099 
4100 #define T_DIR  1   
4101 #define T_FILE 2   
4102 #define T_DEV  3   
4103 
4104 struct stat {
4105   short type;  
4106   int dev;     
4107   uint ino;    
4108   short nlink; 
4109   uint size;   
4110 };
4111 
4112 
4113 
4114 
4115 
4116 
4117 
4118 
4119 
4120 
4121 
4122 
4123 
4124 
4125 
4126 
4127 
4128 
4129 
4130 
4131 
4132 
4133 
4134 
4135 
4136 
4137 
4138 
4139 
4140 
4141 
4142 
4143 
4144 
4145 
4146 
4147 
4148 
4149 
4150 
4151 
4152 
4153 
4154 #define ROOTINO 1  
4155 #define BSIZE 512  
4156 
4157 
4158 
4159 
4160 
4161 
4162 
4163 struct superblock {
4164   uint size;         
4165   uint nblocks;      
4166   uint ninodes;      
4167   uint nlog;         
4168   uint logstart;     
4169   uint inodestart;   
4170   uint bmapstart;    
4171 };
4172 
4173 #define NDIRECT 12
4174 #define NINDIRECT (BSIZE / sizeof(uint))
4175 #define MAXFILE (NDIRECT + NINDIRECT)
4176 
4177 
4178 struct dinode {
4179   short type;           
4180   short major;          
4181   short minor;          
4182   short nlink;          
4183   uint size;            
4184   uint addrs[NDIRECT+1];   
4185 };
4186 
4187 
4188 
4189 
4190 
4191 
4192 
4193 
4194 
4195 
4196 
4197 
4198 
4199 
4200 
4201 #define IPB           (BSIZE / sizeof(struct dinode))
4202 
4203 
4204 #define IBLOCK(i, sb)     ((i) / IPB + sb.inodestart)
4205 
4206 
4207 #define BPB           (BSIZE*8)
4208 
4209 
4210 #define BBLOCK(b, sb) (b/BPB + sb.bmapstart)
4211 
4212 
4213 #define DIRSIZ 14
4214 
4215 struct dirent {
4216   ushort inum;
4217   char name[DIRSIZ];
4218 };
4219 
4220 
4221 
4222 
4223 
4224 
4225 
4226 
4227 
4228 
4229 
4230 
4231 
4232 
4233 
4234 
4235 
4236 
4237 
4238 
4239 
4240 
4241 
4242 
4243 
4244 
4245 
4246 
4247 
4248 
4249 
4250 struct file {
4251   enum { FD_NONE, FD_PIPE, FD_INODE } type;
4252   int ref; 
4253   char readable;
4254   char writable;
4255   struct pipe *pipe;
4256   struct inode *ip;
4257   uint off;
4258 };
4259 
4260 
4261 
4262 struct inode {
4263   uint dev;           
4264   uint inum;          
4265   int ref;            
4266   struct sleeplock lock;
4267   int flags;          
4268 
4269   short type;         
4270   short major;
4271   short minor;
4272   short nlink;
4273   uint size;
4274   uint addrs[NDIRECT+1];
4275 };
4276 #define I_VALID 0x2
4277 
4278 
4279 
4280 struct devsw {
4281   int (*read)(struct inode*, char*, int);
4282   int (*write)(struct inode*, char*, int);
4283 };
4284 
4285 extern struct devsw devsw[];
4286 
4287 #define CONSOLE 1
4288 
4289 
4290 
4291 
4292 
4293 
4294 
4295 
4296 
4297 
4298 
4299 
4300 
4301 
4302 
4303 
4304 
4305 
4306 
4307 
4308 
4309 
4310 
4311 
4312 
4313 
4314 
4315 
4316 
4317 
4318 
4319 
4320 
4321 
4322 
4323 
4324 
4325 
4326 
4327 
4328 
4329 
4330 
4331 
4332 
4333 
4334 
4335 
4336 
4337 
4338 
4339 
4340 
4341 
4342 
4343 
4344 
4345 
4346 
4347 
4348 
4349 
4350 
4351 
4352 #include "types.h"
4353 #include "defs.h"
4354 #include "param.h"
4355 #include "memlayout.h"
4356 #include "mmu.h"
4357 #include "proc.h"
4358 #include "x86.h"
4359 #include "traps.h"
4360 #include "spinlock.h"
4361 #include "sleeplock.h"
4362 #include "fs.h"
4363 #include "buf.h"
4364 
4365 #define SECTOR_SIZE   512
4366 #define IDE_BSY       0x80
4367 #define IDE_DRDY      0x40
4368 #define IDE_DF        0x20
4369 #define IDE_ERR       0x01
4370 
4371 #define IDE_CMD_READ  0x20
4372 #define IDE_CMD_WRITE 0x30
4373 #define IDE_CMD_RDMUL 0xc4
4374 #define IDE_CMD_WRMUL 0xc5
4375 
4376 
4377 
4378 
4379 
4380 static struct spinlock idelock;
4381 static struct buf *idequeue;
4382 
4383 static int havedisk1;
4384 static void idestart(struct buf*);
4385 
4386 
4387 static int
4388 idewait(int checkerr)
4389 {
4390   int r;
4391 
4392   while(((r = inb(0x1f7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
4393     ;
4394   if(checkerr && (r & (IDE_DF|IDE_ERR)) != 0)
4395     return -1;
4396   return 0;
4397 }
4398 
4399 
4400 void
4401 ideinit(void)
4402 {
4403   int i;
4404 
4405   initlock(&idelock, "ide");
4406   picenable(IRQ_IDE);
4407   ioapicenable(IRQ_IDE, ncpu - 1);
4408   idewait(0);
4409 
4410   
4411   outb(0x1f6, 0xe0 | (1<<4));
4412   for(i=0; i<1000; i++){
4413     if(inb(0x1f7) != 0){
4414       havedisk1 = 1;
4415       break;
4416     }
4417   }
4418 
4419   
4420   outb(0x1f6, 0xe0 | (0<<4));
4421 }
4422 
4423 
4424 static void
4425 idestart(struct buf *b)
4426 {
4427   if(b == 0)
4428     panic("idestart");
4429   if(b->blockno >= FSSIZE)
4430     panic("incorrect blockno");
4431   int sector_per_block =  BSIZE/SECTOR_SIZE;
4432   int sector = b->blockno * sector_per_block;
4433   int read_cmd = (sector_per_block == 1) ? IDE_CMD_READ :  IDE_CMD_RDMUL;
4434   int write_cmd = (sector_per_block == 1) ? IDE_CMD_WRITE : IDE_CMD_WRMUL;
4435 
4436   if (sector_per_block > 7) panic("idestart");
4437 
4438   idewait(0);
4439   outb(0x3f6, 0);  
4440   outb(0x1f2, sector_per_block);  
4441   outb(0x1f3, sector & 0xff);
4442   outb(0x1f4, (sector >> 8) & 0xff);
4443   outb(0x1f5, (sector >> 16) & 0xff);
4444   outb(0x1f6, 0xe0 | ((b->dev&1)<<4) | ((sector>>24)&0x0f));
4445   if(b->flags & B_DIRTY){
4446     outb(0x1f7, write_cmd);
4447     outsl(0x1f0, b->data, BSIZE/4);
4448   } else {
4449     outb(0x1f7, read_cmd);
4450   }
4451 }
4452 
4453 
4454 void
4455 ideintr(void)
4456 {
4457   struct buf *b;
4458 
4459   
4460   acquire(&idelock);
4461   if((b = idequeue) == 0){
4462     release(&idelock);
4463     
4464     return;
4465   }
4466   idequeue = b->qnext;
4467 
4468   
4469   if(!(b->flags & B_DIRTY) && idewait(1) >= 0)
4470     insl(0x1f0, b->data, BSIZE/4);
4471 
4472   
4473   b->flags |= B_VALID;
4474   b->flags &= ~B_DIRTY;
4475   wakeup(b);
4476 
4477   
4478   if(idequeue != 0)
4479     idestart(idequeue);
4480 
4481   release(&idelock);
4482 }
4483 
4484 
4485 
4486 
4487 
4488 
4489 
4490 
4491 
4492 
4493 
4494 
4495 
4496 
4497 
4498 
4499 
4500 
4501 
4502 
4503 void
4504 iderw(struct buf *b)
4505 {
4506   struct buf **pp;
4507 
4508   if(!holdingsleep(&b->lock))
4509     panic("iderw: buf not locked");
4510   if((b->flags & (B_VALID|B_DIRTY)) == B_VALID)
4511     panic("iderw: nothing to do");
4512   if(b->dev != 0 && !havedisk1)
4513     panic("iderw: ide disk 1 not present");
4514 
4515   acquire(&idelock);  
4516 
4517   
4518   b->qnext = 0;
4519   for(pp=&idequeue; *pp; pp=&(*pp)->qnext)  
4520     ;
4521   *pp = b;
4522 
4523   
4524   if(idequeue == b)
4525     idestart(b);
4526 
4527   
4528   while((b->flags & (B_VALID|B_DIRTY)) != B_VALID){
4529     sleep(b, &idelock);
4530   }
4531 
4532   release(&idelock);
4533 }
4534 
4535 
4536 
4537 
4538 
4539 
4540 
4541 
4542 
4543 
4544 
4545 
4546 
4547 
4548 
4549 
4550 
4551 
4552 
4553 
4554 
4555 
4556 
4557 
4558 
4559 
4560 
4561 
4562 
4563 
4564 
4565 
4566 
4567 
4568 
4569 
4570 #include "types.h"
4571 #include "defs.h"
4572 #include "param.h"
4573 #include "spinlock.h"
4574 #include "sleeplock.h"
4575 #include "fs.h"
4576 #include "buf.h"
4577 
4578 struct {
4579   struct spinlock lock;
4580   struct buf buf[NBUF];
4581 
4582   
4583   
4584   struct buf head;
4585 } bcache;
4586 
4587 void
4588 binit(void)
4589 {
4590   struct buf *b;
4591 
4592   initlock(&bcache.lock, "bcache");
4593 
4594 
4595 
4596 
4597 
4598 
4599 
4600   
4601   bcache.head.prev = &bcache.head;
4602   bcache.head.next = &bcache.head;
4603   for(b = bcache.buf; b < bcache.buf+NBUF; b++){
4604     b->next = bcache.head.next;
4605     b->prev = &bcache.head;
4606     initsleeplock(&b->lock, "buffer");
4607     bcache.head.next->prev = b;
4608     bcache.head.next = b;
4609   }
4610 }
4611 
4612 
4613 
4614 
4615 static struct buf*
4616 bget(uint dev, uint blockno)
4617 {
4618   struct buf *b;
4619 
4620   acquire(&bcache.lock);
4621 
4622   
4623   for(b = bcache.head.next; b != &bcache.head; b = b->next){
4624     if(b->dev == dev && b->blockno == blockno){
4625       b->refcnt++;
4626       release(&bcache.lock);
4627       acquiresleep(&b->lock);
4628       return b;
4629     }
4630   }
4631 
4632   
4633   
4634   
4635   for(b = bcache.head.prev; b != &bcache.head; b = b->prev){
4636     if(b->refcnt == 0 && (b->flags & B_DIRTY) == 0) {
4637       b->dev = dev;
4638       b->blockno = blockno;
4639       b->flags = 0;
4640       b->refcnt = 1;
4641       release(&bcache.lock);
4642       acquiresleep(&b->lock);
4643       return b;
4644     }
4645   }
4646   panic("bget: no buffers");
4647 }
4648 
4649 
4650 
4651 struct buf*
4652 bread(uint dev, uint blockno)
4653 {
4654   struct buf *b;
4655 
4656   b = bget(dev, blockno);
4657   if(!(b->flags & B_VALID)) {
4658     iderw(b);
4659   }
4660   return b;
4661 }
4662 
4663 
4664 void
4665 bwrite(struct buf *b)
4666 {
4667   if(!holdingsleep(&b->lock))
4668     panic("bwrite");
4669   b->flags |= B_DIRTY;
4670   iderw(b);
4671 }
4672 
4673 
4674 
4675 void
4676 brelse(struct buf *b)
4677 {
4678   if(!holdingsleep(&b->lock))
4679     panic("brelse");
4680 
4681   releasesleep(&b->lock);
4682 
4683   acquire(&bcache.lock);
4684   b->refcnt--;
4685   if (b->refcnt == 0) {
4686     
4687     b->next->prev = b->prev;
4688     b->prev->next = b->next;
4689     b->next = bcache.head.next;
4690     b->prev = &bcache.head;
4691     bcache.head.next->prev = b;
4692     bcache.head.next = b;
4693   }
4694 
4695   release(&bcache.lock);
4696 }
4697 
4698 
4699 
4700 
4701 
4702 
4703 
4704 
4705 
4706 
4707 
4708 
4709 
4710 
4711 
4712 
4713 
4714 
4715 
4716 
4717 
4718 
4719 
4720 
4721 
4722 
4723 
4724 
4725 
4726 
4727 
4728 
4729 
4730 
4731 
4732 
4733 
4734 
4735 
4736 
4737 
4738 
4739 
4740 
4741 
4742 
4743 
4744 
4745 
4746 
4747 
4748 
4749 
4750 
4751 
4752 #include "types.h"
4753 #include "defs.h"
4754 #include "param.h"
4755 #include "x86.h"
4756 #include "memlayout.h"
4757 #include "mmu.h"
4758 #include "proc.h"
4759 #include "spinlock.h"
4760 #include "sleeplock.h"
4761 
4762 void
4763 initsleeplock(struct sleeplock *lk, char *name)
4764 {
4765   initlock(&lk->lk, "sleep lock");
4766   lk->name = name;
4767   lk->locked = 0;
4768   lk->pid = 0;
4769 }
4770 
4771 void
4772 acquiresleep(struct sleeplock *lk)
4773 {
4774   acquire(&lk->lk);
4775   while (lk->locked) {
4776     sleep(lk, &lk->lk);
4777   }
4778   lk->locked = 1;
4779   lk->pid = proc->pid;
4780   release(&lk->lk);
4781 }
4782 
4783 void
4784 releasesleep(struct sleeplock *lk)
4785 {
4786   acquire(&lk->lk);
4787   lk->locked = 0;
4788   lk->pid = 0;
4789   wakeup(lk);
4790   release(&lk->lk);
4791 }
4792 
4793 
4794 
4795 
4796 
4797 
4798 
4799 
4800 int
4801 holdingsleep(struct sleeplock *lk)
4802 {
4803   int r;
4804 
4805   acquire(&lk->lk);
4806   r = lk->locked;
4807   release(&lk->lk);
4808   return r;
4809 }
4810 
4811 
4812 
4813 
4814 
4815 
4816 
4817 
4818 
4819 
4820 
4821 
4822 
4823 
4824 
4825 
4826 
4827 
4828 
4829 
4830 
4831 
4832 
4833 
4834 
4835 
4836 
4837 
4838 
4839 
4840 
4841 
4842 
4843 
4844 
4845 
4846 
4847 
4848 
4849 
4850 #include "types.h"
4851 #include "defs.h"
4852 #include "param.h"
4853 #include "spinlock.h"
4854 #include "sleeplock.h"
4855 #include "fs.h"
4856 #include "buf.h"
4857 
4858 
4859 
4860 
4861 
4862 
4863 
4864 
4865 
4866 
4867 
4868 
4869 
4870 
4871 
4872 
4873 
4874 
4875 
4876 
4877 
4878 
4879 
4880 
4881 
4882 
4883 struct logheader {
4884   int n;
4885   int block[LOGSIZE];
4886 };
4887 
4888 struct log {
4889   struct spinlock lock;
4890   int start;
4891   int size;
4892   int outstanding; 
4893   int committing;  
4894   int dev;
4895   struct logheader lh;
4896 };
4897 
4898 
4899 
4900 struct log log;
4901 
4902 static void recover_from_log(void);
4903 static void commit();
4904 
4905 void
4906 initlog(int dev)
4907 {
4908   if (sizeof(struct logheader) >= BSIZE)
4909     panic("initlog: too big logheader");
4910 
4911   struct superblock sb;
4912   initlock(&log.lock, "log");
4913   readsb(dev, &sb);
4914   log.start = sb.logstart;
4915   log.size = sb.nlog;
4916   log.dev = dev;
4917   recover_from_log();
4918 }
4919 
4920 
4921 static void
4922 install_trans(void)
4923 {
4924   int tail;
4925 
4926   for (tail = 0; tail < log.lh.n; tail++) {
4927     struct buf *lbuf = bread(log.dev, log.start+tail+1); 
4928     struct buf *dbuf = bread(log.dev, log.lh.block[tail]); 
4929     memmove(dbuf->data, lbuf->data, BSIZE);  
4930     bwrite(dbuf);  
4931     brelse(lbuf);
4932     brelse(dbuf);
4933   }
4934 }
4935 
4936 
4937 static void
4938 read_head(void)
4939 {
4940   struct buf *buf = bread(log.dev, log.start);
4941   struct logheader *lh = (struct logheader *) (buf->data);
4942   int i;
4943   log.lh.n = lh->n;
4944   for (i = 0; i < log.lh.n; i++) {
4945     log.lh.block[i] = lh->block[i];
4946   }
4947   brelse(buf);
4948 }
4949 
4950 
4951 
4952 
4953 static void
4954 write_head(void)
4955 {
4956   struct buf *buf = bread(log.dev, log.start);
4957   struct logheader *hb = (struct logheader *) (buf->data);
4958   int i;
4959   hb->n = log.lh.n;
4960   for (i = 0; i < log.lh.n; i++) {
4961     hb->block[i] = log.lh.block[i];
4962   }
4963   bwrite(buf);
4964   brelse(buf);
4965 }
4966 
4967 static void
4968 recover_from_log(void)
4969 {
4970   read_head();
4971   install_trans(); 
4972   log.lh.n = 0;
4973   write_head(); 
4974 }
4975 
4976 
4977 void
4978 begin_op(void)
4979 {
4980   acquire(&log.lock);
4981   while(1){
4982     if(log.committing){
4983       sleep(&log, &log.lock);
4984     } else if(log.lh.n + (log.outstanding+1)*MAXOPBLOCKS > LOGSIZE){
4985       
4986       sleep(&log, &log.lock);
4987     } else {
4988       log.outstanding += 1;
4989       release(&log.lock);
4990       break;
4991     }
4992   }
4993 }
4994 
4995 
4996 
4997 
4998 
4999 
5000 
5001 
5002 void
5003 end_op(void)
5004 {
5005   int do_commit = 0;
5006 
5007   acquire(&log.lock);
5008   log.outstanding -= 1;
5009   if(log.committing)
5010     panic("log.committing");
5011   if(log.outstanding == 0){
5012     do_commit = 1;
5013     log.committing = 1;
5014   } else {
5015     
5016     wakeup(&log);
5017   }
5018   release(&log.lock);
5019 
5020   if(do_commit){
5021     
5022     
5023     commit();
5024     acquire(&log.lock);
5025     log.committing = 0;
5026     wakeup(&log);
5027     release(&log.lock);
5028   }
5029 }
5030 
5031 
5032 static void
5033 write_log(void)
5034 {
5035   int tail;
5036 
5037   for (tail = 0; tail < log.lh.n; tail++) {
5038     struct buf *to = bread(log.dev, log.start+tail+1); 
5039     struct buf *from = bread(log.dev, log.lh.block[tail]); 
5040     memmove(to->data, from->data, BSIZE);
5041     bwrite(to);  
5042     brelse(from);
5043     brelse(to);
5044   }
5045 }
5046 
5047 
5048 
5049 
5050 static void
5051 commit()
5052 {
5053   if (log.lh.n > 0) {
5054     write_log();     
5055     write_head();    
5056     install_trans(); 
5057     log.lh.n = 0;
5058     write_head();    
5059   }
5060 }
5061 
5062 
5063 
5064 
5065 
5066 
5067 
5068 
5069 
5070 
5071 void
5072 log_write(struct buf *b)
5073 {
5074   int i;
5075 
5076   if (log.lh.n >= LOGSIZE || log.lh.n >= log.size - 1)
5077     panic("too big a transaction");
5078   if (log.outstanding < 1)
5079     panic("log_write outside of trans");
5080 
5081   acquire(&log.lock);
5082   for (i = 0; i < log.lh.n; i++) {
5083     if (log.lh.block[i] == b->blockno)   
5084       break;
5085   }
5086   log.lh.block[i] = b->blockno;
5087   if (i == log.lh.n)
5088     log.lh.n++;
5089   b->flags |= B_DIRTY; 
5090   release(&log.lock);
5091 }
5092 
5093 
5094 
5095 
5096 
5097 
5098 
5099 
5100 
5101 
5102 
5103 
5104 
5105 
5106 
5107 
5108 
5109 
5110 
5111 #include "types.h"
5112 #include "defs.h"
5113 #include "param.h"
5114 #include "stat.h"
5115 #include "mmu.h"
5116 #include "proc.h"
5117 #include "spinlock.h"
5118 #include "sleeplock.h"
5119 #include "fs.h"
5120 #include "buf.h"
5121 #include "file.h"
5122 
5123 #define min(a, b) ((a) < (b) ? (a) : (b))
5124 static void itrunc(struct inode*);
5125 
5126 
5127 struct superblock sb;
5128 
5129 
5130 void
5131 readsb(int dev, struct superblock *sb)
5132 {
5133   struct buf *bp;
5134 
5135   bp = bread(dev, 1);
5136   memmove(sb, bp->data, sizeof(*sb));
5137   brelse(bp);
5138 }
5139 
5140 
5141 
5142 
5143 
5144 
5145 
5146 
5147 
5148 
5149 
5150 
5151 static void
5152 bzero(int dev, int bno)
5153 {
5154   struct buf *bp;
5155 
5156   bp = bread(dev, bno);
5157   memset(bp->data, 0, BSIZE);
5158   log_write(bp);
5159   brelse(bp);
5160 }
5161 
5162 
5163 
5164 
5165 static uint
5166 balloc(uint dev)
5167 {
5168   int b, bi, m;
5169   struct buf *bp;
5170 
5171   bp = 0;
5172   for(b = 0; b < sb.size; b += BPB){
5173     bp = bread(dev, BBLOCK(b, sb));
5174     for(bi = 0; bi < BPB && b + bi < sb.size; bi++){
5175       m = 1 << (bi % 8);
5176       if((bp->data[bi/8] & m) == 0){  
5177         bp->data[bi/8] |= m;  
5178         log_write(bp);
5179         brelse(bp);
5180         bzero(dev, b + bi);
5181         return b + bi;
5182       }
5183     }
5184     brelse(bp);
5185   }
5186   panic("balloc: out of blocks");
5187 }
5188 
5189 
5190 
5191 
5192 
5193 
5194 
5195 
5196 
5197 
5198 
5199 
5200 
5201 static void
5202 bfree(int dev, uint b)
5203 {
5204   struct buf *bp;
5205   int bi, m;
5206 
5207   readsb(dev, &sb);
5208   bp = bread(dev, BBLOCK(b, sb));
5209   bi = b % BPB;
5210   m = 1 << (bi % 8);
5211   if((bp->data[bi/8] & m) == 0)
5212     panic("freeing free block");
5213   bp->data[bi/8] &= ~m;
5214   log_write(bp);
5215   brelse(bp);
5216 }
5217 
5218 
5219 
5220 
5221 
5222 
5223 
5224 
5225 
5226 
5227 
5228 
5229 
5230 
5231 
5232 
5233 
5234 
5235 
5236 
5237 
5238 
5239 
5240 
5241 
5242 
5243 
5244 
5245 
5246 
5247 
5248 
5249 
5250 
5251 
5252 
5253 
5254 
5255 
5256 
5257 
5258 
5259 
5260 
5261 
5262 
5263 
5264 
5265 
5266 
5267 
5268 
5269 
5270 
5271 
5272 
5273 
5274 
5275 
5276 
5277 
5278 struct {
5279   struct spinlock lock;
5280   struct inode inode[NINODE];
5281 } icache;
5282 
5283 void
5284 iinit(int dev)
5285 {
5286   int i = 0;
5287 
5288   initlock(&icache.lock, "icache");
5289   for(i = 0; i < NINODE; i++) {
5290     initsleeplock(&icache.inode[i].lock, "inode");
5291   }
5292 
5293   readsb(dev, &sb);
5294   cprintf("sb: size %d nblocks %d ninodes %d nlog %d logstart %d\
5295  inodestart %d bmap start %d\n", sb.size, sb.nblocks,
5296           sb.ninodes, sb.nlog, sb.logstart, sb.inodestart,
5297           sb.bmapstart);
5298 }
5299 
5300 static struct inode* iget(uint dev, uint inum);
5301 
5302 
5303 
5304 
5305 
5306 
5307 
5308 
5309 
5310 
5311 
5312 
5313 
5314 
5315 
5316 
5317 
5318 
5319 
5320 
5321 
5322 
5323 
5324 
5325 
5326 
5327 
5328 
5329 
5330 
5331 
5332 
5333 
5334 
5335 
5336 
5337 
5338 
5339 
5340 
5341 
5342 
5343 
5344 
5345 
5346 
5347 
5348 
5349 
5350 
5351 
5352 struct inode*
5353 ialloc(uint dev, short type)
5354 {
5355   int inum;
5356   struct buf *bp;
5357   struct dinode *dip;
5358 
5359   for(inum = 1; inum < sb.ninodes; inum++){
5360     bp = bread(dev, IBLOCK(inum, sb));
5361     dip = (struct dinode*)bp->data + inum%IPB;
5362     if(dip->type == 0){  
5363       memset(dip, 0, sizeof(*dip));
5364       dip->type = type;
5365       log_write(bp);   
5366       brelse(bp);
5367       return iget(dev, inum);
5368     }
5369     brelse(bp);
5370   }
5371   panic("ialloc: no inodes");
5372 }
5373 
5374 
5375 void
5376 iupdate(struct inode *ip)
5377 {
5378   struct buf *bp;
5379   struct dinode *dip;
5380 
5381   bp = bread(ip->dev, IBLOCK(ip->inum, sb));
5382   dip = (struct dinode*)bp->data + ip->inum%IPB;
5383   dip->type = ip->type;
5384   dip->major = ip->major;
5385   dip->minor = ip->minor;
5386   dip->nlink = ip->nlink;
5387   dip->size = ip->size;
5388   memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
5389   log_write(bp);
5390   brelse(bp);
5391 }
5392 
5393 
5394 
5395 
5396 
5397 
5398 
5399 
5400 
5401 
5402 
5403 static struct inode*
5404 iget(uint dev, uint inum)
5405 {
5406   struct inode *ip, *empty;
5407 
5408   acquire(&icache.lock);
5409 
5410   
5411   empty = 0;
5412   for(ip = &icache.inode[0]; ip < &icache.inode[NINODE]; ip++){
5413     if(ip->ref > 0 && ip->dev == dev && ip->inum == inum){
5414       ip->ref++;
5415       release(&icache.lock);
5416       return ip;
5417     }
5418     if(empty == 0 && ip->ref == 0)    
5419       empty = ip;
5420   }
5421 
5422   
5423   if(empty == 0)
5424     panic("iget: no inodes");
5425 
5426   ip = empty;
5427   ip->dev = dev;
5428   ip->inum = inum;
5429   ip->ref = 1;
5430   ip->flags = 0;
5431   release(&icache.lock);
5432 
5433   return ip;
5434 }
5435 
5436 
5437 
5438 struct inode*
5439 idup(struct inode *ip)
5440 {
5441   acquire(&icache.lock);
5442   ip->ref++;
5443   release(&icache.lock);
5444   return ip;
5445 }
5446 
5447 
5448 
5449 
5450 
5451 
5452 void
5453 ilock(struct inode *ip)
5454 {
5455   struct buf *bp;
5456   struct dinode *dip;
5457 
5458   if(ip == 0 || ip->ref < 1)
5459     panic("ilock");
5460 
5461   acquiresleep(&ip->lock);
5462 
5463   if(!(ip->flags & I_VALID)){
5464     bp = bread(ip->dev, IBLOCK(ip->inum, sb));
5465     dip = (struct dinode*)bp->data + ip->inum%IPB;
5466     ip->type = dip->type;
5467     ip->major = dip->major;
5468     ip->minor = dip->minor;
5469     ip->nlink = dip->nlink;
5470     ip->size = dip->size;
5471     memmove(ip->addrs, dip->addrs, sizeof(ip->addrs));
5472     brelse(bp);
5473     ip->flags |= I_VALID;
5474     if(ip->type == 0)
5475       panic("ilock: no type");
5476   }
5477 }
5478 
5479 
5480 void
5481 iunlock(struct inode *ip)
5482 {
5483   if(ip == 0 || !holdingsleep(&ip->lock) || ip->ref < 1)
5484     panic("iunlock");
5485 
5486   releasesleep(&ip->lock);
5487 }
5488 
5489 
5490 
5491 
5492 
5493 
5494 
5495 
5496 
5497 
5498 
5499 
5500 
5501 
5502 
5503 
5504 
5505 
5506 
5507 void
5508 iput(struct inode *ip)
5509 {
5510   acquire(&icache.lock);
5511   if(ip->ref == 1 && (ip->flags & I_VALID) && ip->nlink == 0){
5512     
5513     release(&icache.lock);
5514     itrunc(ip);
5515     ip->type = 0;
5516     iupdate(ip);
5517     acquire(&icache.lock);
5518     ip->flags = 0;
5519   }
5520   ip->ref--;
5521   release(&icache.lock);
5522 }
5523 
5524 
5525 void
5526 iunlockput(struct inode *ip)
5527 {
5528   iunlock(ip);
5529   iput(ip);
5530 }
5531 
5532 
5533 
5534 
5535 
5536 
5537 
5538 
5539 
5540 
5541 
5542 
5543 
5544 
5545 
5546 
5547 
5548 
5549 
5550 
5551 
5552 
5553 
5554 
5555 
5556 
5557 
5558 
5559 static uint
5560 bmap(struct inode *ip, uint bn)
5561 {
5562   uint addr, *a;
5563   struct buf *bp;
5564 
5565   if(bn < NDIRECT){
5566     if((addr = ip->addrs[bn]) == 0)
5567       ip->addrs[bn] = addr = balloc(ip->dev);
5568     return addr;
5569   }
5570   bn -= NDIRECT;
5571 
5572   if(bn < NINDIRECT){
5573     
5574     if((addr = ip->addrs[NDIRECT]) == 0)
5575       ip->addrs[NDIRECT] = addr = balloc(ip->dev);
5576     bp = bread(ip->dev, addr);
5577     a = (uint*)bp->data;
5578     if((addr = a[bn]) == 0){
5579       a[bn] = addr = balloc(ip->dev);
5580       log_write(bp);
5581     }
5582     brelse(bp);
5583     return addr;
5584   }
5585 
5586   panic("bmap: out of range");
5587 }
5588 
5589 
5590 
5591 
5592 
5593 
5594 
5595 
5596 
5597 
5598 
5599 
5600 
5601 
5602 
5603 
5604 
5605 static void
5606 itrunc(struct inode *ip)
5607 {
5608   int i, j;
5609   struct buf *bp;
5610   uint *a;
5611 
5612   for(i = 0; i < NDIRECT; i++){
5613     if(ip->addrs[i]){
5614       bfree(ip->dev, ip->addrs[i]);
5615       ip->addrs[i] = 0;
5616     }
5617   }
5618 
5619   if(ip->addrs[NDIRECT]){
5620     bp = bread(ip->dev, ip->addrs[NDIRECT]);
5621     a = (uint*)bp->data;
5622     for(j = 0; j < NINDIRECT; j++){
5623       if(a[j])
5624         bfree(ip->dev, a[j]);
5625     }
5626     brelse(bp);
5627     bfree(ip->dev, ip->addrs[NDIRECT]);
5628     ip->addrs[NDIRECT] = 0;
5629   }
5630 
5631   ip->size = 0;
5632   iupdate(ip);
5633 }
5634 
5635 
5636 void
5637 stati(struct inode *ip, struct stat *st)
5638 {
5639   st->dev = ip->dev;
5640   st->ino = ip->inum;
5641   st->type = ip->type;
5642   st->nlink = ip->nlink;
5643   st->size = ip->size;
5644 }
5645 
5646 
5647 
5648 
5649 
5650 
5651 int
5652 readi(struct inode *ip, char *dst, uint off, uint n)
5653 {
5654   uint tot, m;
5655   struct buf *bp;
5656 
5657   if(ip->type == T_DEV){
5658     if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].read)
5659       return -1;
5660     return devsw[ip->major].read(ip, dst, n);
5661   }
5662 
5663   if(off > ip->size || off + n < off)
5664     return -1;
5665   if(off + n > ip->size)
5666     n = ip->size - off;
5667 
5668   for(tot=0; tot<n; tot+=m, off+=m, dst+=m){
5669     bp = bread(ip->dev, bmap(ip, off/BSIZE));
5670     m = min(n - tot, BSIZE - off%BSIZE);
5671     /*
5672     cprintf("data off %d:\n", off);
5673     for (int j = 0; j < min(m, 10); j++) {
5674       cprintf("%x ", bp->data[off%BSIZE+j]);
5675     }
5676     cprintf("\n");
5677     */
5678     memmove(dst, bp->data + off%BSIZE, m);
5679     brelse(bp);
5680   }
5681   return n;
5682 }
5683 
5684 
5685 
5686 
5687 
5688 
5689 
5690 
5691 
5692 
5693 
5694 
5695 
5696 
5697 
5698 
5699 
5700 
5701 int
5702 writei(struct inode *ip, char *src, uint off, uint n)
5703 {
5704   uint tot, m;
5705   struct buf *bp;
5706 
5707   if(ip->type == T_DEV){
5708     if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].write)
5709       return -1;
5710     return devsw[ip->major].write(ip, src, n);
5711   }
5712 
5713   if(off > ip->size || off + n < off)
5714     return -1;
5715   if(off + n > MAXFILE*BSIZE)
5716     return -1;
5717 
5718   for(tot=0; tot<n; tot+=m, off+=m, src+=m){
5719     bp = bread(ip->dev, bmap(ip, off/BSIZE));
5720     m = min(n - tot, BSIZE - off%BSIZE);
5721     memmove(bp->data + off%BSIZE, src, m);
5722     log_write(bp);
5723     brelse(bp);
5724   }
5725 
5726   if(n > 0 && off > ip->size){
5727     ip->size = off;
5728     iupdate(ip);
5729   }
5730   return n;
5731 }
5732 
5733 
5734 
5735 
5736 
5737 
5738 
5739 
5740 
5741 
5742 
5743 
5744 
5745 
5746 
5747 
5748 
5749 
5750 
5751 
5752 int
5753 namecmp(const char *s, const char *t)
5754 {
5755   return strncmp(s, t, DIRSIZ);
5756 }
5757 
5758 
5759 
5760 struct inode*
5761 dirlookup(struct inode *dp, char *name, uint *poff)
5762 {
5763   uint off, inum;
5764   struct dirent de;
5765 
5766   if(dp->type != T_DIR)
5767     panic("dirlookup not DIR");
5768 
5769   for(off = 0; off < dp->size; off += sizeof(de)){
5770     if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
5771       panic("dirlink read");
5772     if(de.inum == 0)
5773       continue;
5774     if(namecmp(name, de.name) == 0){
5775       
5776       if(poff)
5777         *poff = off;
5778       inum = de.inum;
5779       return iget(dp->dev, inum);
5780     }
5781   }
5782 
5783   return 0;
5784 }
5785 
5786 
5787 
5788 
5789 
5790 
5791 
5792 
5793 
5794 
5795 
5796 
5797 
5798 
5799 
5800 
5801 int
5802 dirlink(struct inode *dp, char *name, uint inum)
5803 {
5804   int off;
5805   struct dirent de;
5806   struct inode *ip;
5807 
5808   
5809   if((ip = dirlookup(dp, name, 0)) != 0){
5810     iput(ip);
5811     return -1;
5812   }
5813 
5814   
5815   for(off = 0; off < dp->size; off += sizeof(de)){
5816     if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
5817       panic("dirlink read");
5818     if(de.inum == 0)
5819       break;
5820   }
5821 
5822   strncpy(de.name, name, DIRSIZ);
5823   de.inum = inum;
5824   if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
5825     panic("dirlink");
5826 
5827   return 0;
5828 }
5829 
5830 
5831 
5832 
5833 
5834 
5835 
5836 
5837 
5838 
5839 
5840 
5841 
5842 
5843 
5844 
5845 
5846 
5847 
5848 
5849 
5850 
5851 
5852 
5853 
5854 
5855 
5856 
5857 
5858 
5859 
5860 
5861 
5862 
5863 
5864 static char*
5865 skipelem(char *path, char *name)
5866 {
5867   char *s;
5868   int len;
5869 
5870   while(*path == '/')
5871     path++;
5872   if(*path == 0)
5873     return 0;
5874   s = path;
5875   while(*path != '/' && *path != 0)
5876     path++;
5877   len = path - s;
5878   if(len >= DIRSIZ)
5879     memmove(name, s, DIRSIZ);
5880   else {
5881     memmove(name, s, len);
5882     name[len] = 0;
5883   }
5884   while(*path == '/')
5885     path++;
5886   return path;
5887 }
5888 
5889 
5890 
5891 
5892 
5893 
5894 
5895 
5896 
5897 
5898 
5899 
5900 
5901 
5902 
5903 
5904 static struct inode*
5905 namex(char *path, int nameiparent, char *name)
5906 {
5907   struct inode *ip, *next;
5908 
5909   if(*path == '/')
5910     ip = iget(ROOTDEV, ROOTINO);
5911   else
5912     ip = idup(proc->cwd);
5913 
5914   while((path = skipelem(path, name)) != 0){
5915     ilock(ip);
5916     if(ip->type != T_DIR){
5917       iunlockput(ip);
5918       return 0;
5919     }
5920     if(nameiparent && *path == '\0'){
5921       
5922       iunlock(ip);
5923       return ip;
5924     }
5925     if((next = dirlookup(ip, name, 0)) == 0){
5926       iunlockput(ip);
5927       return 0;
5928     }
5929     iunlockput(ip);
5930     ip = next;
5931   }
5932   if(nameiparent){
5933     iput(ip);
5934     return 0;
5935   }
5936   return ip;
5937 }
5938 
5939 
5940 struct inode*
5941 namei(char *path)
5942 {
5943   char name[DIRSIZ];
5944   return namex(path, 0, name);
5945 }
5946 
5947 
5948 
5949 
5950 struct inode*
5951 nameiparent(char *path, char *name)
5952 {
5953   return namex(path, 1, name);
5954 }
5955 
5956 
5957 
5958 
5959 
5960 
5961 
5962 
5963 
5964 
5965 
5966 
5967 
5968 
5969 
5970 
5971 
5972 
5973 
5974 
5975 
5976 
5977 
5978 
5979 
5980 
5981 
5982 
5983 
5984 
5985 
5986 
5987 
5988 
5989 
5990 
5991 
5992 
5993 
5994 
5995 
5996 
5997 
5998 
5999 
6000 
6001 
6002 
6003 
6004 #include "types.h"
6005 #include "defs.h"
6006 #include "param.h"
6007 #include "fs.h"
6008 #include "spinlock.h"
6009 #include "sleeplock.h"
6010 #include "file.h"
6011 
6012 struct devsw devsw[NDEV];
6013 struct {
6014   struct spinlock lock;
6015   struct file file[NFILE];
6016 } ftable;
6017 
6018 void
6019 fileinit(void)
6020 {
6021   initlock(&ftable.lock, "ftable");
6022 }
6023 
6024 
6025 struct file*
6026 filealloc(void)
6027 {
6028   struct file *f;
6029 
6030   acquire(&ftable.lock);
6031   for(f = ftable.file; f < ftable.file + NFILE; f++){
6032     if(f->ref == 0){
6033       f->ref = 1;
6034       release(&ftable.lock);
6035       return f;
6036     }
6037   }
6038   release(&ftable.lock);
6039   return 0;
6040 }
6041 
6042 
6043 
6044 
6045 
6046 
6047 
6048 
6049 
6050 
6051 struct file*
6052 filedup(struct file *f)
6053 {
6054   acquire(&ftable.lock);
6055   if(f->ref < 1)
6056     panic("filedup");
6057   f->ref++;
6058   release(&ftable.lock);
6059   return f;
6060 }
6061 
6062 
6063 void
6064 fileclose(struct file *f)
6065 {
6066   struct file ff;
6067 
6068   acquire(&ftable.lock);
6069   if(f->ref < 1)
6070     panic("fileclose");
6071   if(--f->ref > 0){
6072     release(&ftable.lock);
6073     return;
6074   }
6075   ff = *f;
6076   f->ref = 0;
6077   f->type = FD_NONE;
6078   release(&ftable.lock);
6079 
6080   if(ff.type == FD_PIPE)
6081     pipeclose(ff.pipe, ff.writable);
6082   else if(ff.type == FD_INODE){
6083     begin_op();
6084     iput(ff.ip);
6085     end_op();
6086   }
6087 }
6088 
6089 
6090 
6091 
6092 
6093 
6094 
6095 
6096 
6097 
6098 
6099 
6100 
6101 int
6102 filestat(struct file *f, struct stat *st)
6103 {
6104   if(f->type == FD_INODE){
6105     ilock(f->ip);
6106     stati(f->ip, st);
6107     iunlock(f->ip);
6108     return 0;
6109   }
6110   return -1;
6111 }
6112 
6113 
6114 int
6115 fileread(struct file *f, char *addr, int n)
6116 {
6117   int r;
6118 
6119   if(f->readable == 0)
6120     return -1;
6121   if(f->type == FD_PIPE)
6122     return piperead(f->pipe, addr, n);
6123   if(f->type == FD_INODE){
6124     ilock(f->ip);
6125     if((r = readi(f->ip, addr, f->off, n)) > 0)
6126       f->off += r;
6127     iunlock(f->ip);
6128     return r;
6129   }
6130   panic("fileread");
6131 }
6132 
6133 
6134 
6135 
6136 
6137 
6138 
6139 
6140 
6141 
6142 
6143 
6144 
6145 
6146 
6147 
6148 
6149 
6150 
6151 int
6152 filewrite(struct file *f, char *addr, int n)
6153 {
6154   int r;
6155 
6156   if(f->writable == 0)
6157     return -1;
6158   if(f->type == FD_PIPE)
6159     return pipewrite(f->pipe, addr, n);
6160   if(f->type == FD_INODE){
6161     
6162     
6163     
6164     
6165     
6166     
6167     int max = ((LOGSIZE-1-1-2) / 2) * 512;
6168     int i = 0;
6169     while(i < n){
6170       int n1 = n - i;
6171       if(n1 > max)
6172         n1 = max;
6173 
6174       begin_op();
6175       ilock(f->ip);
6176       if ((r = writei(f->ip, addr + i, f->off, n1)) > 0)
6177         f->off += r;
6178       iunlock(f->ip);
6179       end_op();
6180 
6181       if(r < 0)
6182         break;
6183       if(r != n1)
6184         panic("short filewrite");
6185       i += r;
6186     }
6187     return i == n ? n : -1;
6188   }
6189   panic("filewrite");
6190 }
6191 
6192 
6193 
6194 
6195 
6196 
6197 
6198 
6199 
6200 
6201 
6202 
6203 
6204 
6205 
6206 #include "types.h"
6207 #include "defs.h"
6208 #include "param.h"
6209 #include "stat.h"
6210 #include "mmu.h"
6211 #include "proc.h"
6212 #include "fs.h"
6213 #include "spinlock.h"
6214 #include "sleeplock.h"
6215 #include "file.h"
6216 #include "fcntl.h"
6217 
6218 
6219 
6220 static int
6221 argfd(int n, int *pfd, struct file **pf)
6222 {
6223   int fd;
6224   struct file *f;
6225 
6226   if(argint(n, &fd) < 0)
6227     return -1;
6228   if(fd < 0 || fd >= NOFILE || (f=proc->ofile[fd]) == 0)
6229     return -1;
6230   if(pfd)
6231     *pfd = fd;
6232   if(pf)
6233     *pf = f;
6234   return 0;
6235 }
6236 
6237 
6238 
6239 
6240 
6241 
6242 
6243 
6244 
6245 
6246 
6247 
6248 
6249 
6250 
6251 
6252 static int
6253 fdalloc(struct file *f)
6254 {
6255   int fd;
6256 
6257   for(fd = 0; fd < NOFILE; fd++){
6258     if(proc->ofile[fd] == 0){
6259       proc->ofile[fd] = f;
6260       return fd;
6261     }
6262   }
6263   return -1;
6264 }
6265 
6266 int
6267 sys_dup(void)
6268 {
6269   struct file *f;
6270   int fd;
6271 
6272   if(argfd(0, 0, &f) < 0)
6273     return -1;
6274   if((fd=fdalloc(f)) < 0)
6275     return -1;
6276   filedup(f);
6277   return fd;
6278 }
6279 
6280 int
6281 sys_read(void)
6282 {
6283   struct file *f;
6284   int n;
6285   char *p;
6286 
6287   if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &p, n) < 0)
6288     return -1;
6289   return fileread(f, p, n);
6290 }
6291 
6292 
6293 
6294 
6295 
6296 
6297 
6298 
6299 
6300 int
6301 sys_write(void)
6302 {
6303   struct file *f;
6304   int n;
6305   char *p;
6306 
6307   if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &p, n) < 0)
6308     return -1;
6309   return filewrite(f, p, n);
6310 }
6311 
6312 int
6313 sys_close(void)
6314 {
6315   int fd;
6316   struct file *f;
6317 
6318   if(argfd(0, &fd, &f) < 0)
6319     return -1;
6320   proc->ofile[fd] = 0;
6321   fileclose(f);
6322   return 0;
6323 }
6324 
6325 int
6326 sys_fstat(void)
6327 {
6328   struct file *f;
6329   struct stat *st;
6330 
6331   if(argfd(0, 0, &f) < 0 || argptr(1, (void*)&st, sizeof(*st)) < 0)
6332     return -1;
6333   return filestat(f, st);
6334 }
6335 
6336 
6337 
6338 
6339 
6340 
6341 
6342 
6343 
6344 
6345 
6346 
6347 
6348 
6349 
6350 
6351 int
6352 sys_link(void)
6353 {
6354   char name[DIRSIZ], *new, *old;
6355   struct inode *dp, *ip;
6356 
6357   if(argstr(0, &old) < 0 || argstr(1, &new) < 0)
6358     return -1;
6359 
6360   begin_op();
6361   if((ip = namei(old)) == 0){
6362     end_op();
6363     return -1;
6364   }
6365 
6366   ilock(ip);
6367   if(ip->type == T_DIR){
6368     iunlockput(ip);
6369     end_op();
6370     return -1;
6371   }
6372 
6373   ip->nlink++;
6374   iupdate(ip);
6375   iunlock(ip);
6376 
6377   if((dp = nameiparent(new, name)) == 0)
6378     goto bad;
6379   ilock(dp);
6380   if(dp->dev != ip->dev || dirlink(dp, name, ip->inum) < 0){
6381     iunlockput(dp);
6382     goto bad;
6383   }
6384   iunlockput(dp);
6385   iput(ip);
6386 
6387   end_op();
6388 
6389   return 0;
6390 
6391 bad:
6392   ilock(ip);
6393   ip->nlink--;
6394   iupdate(ip);
6395   iunlockput(ip);
6396   end_op();
6397   return -1;
6398 }
6399 
6400 
6401 static int
6402 isdirempty(struct inode *dp)
6403 {
6404   int off;
6405   struct dirent de;
6406 
6407   for(off=2*sizeof(de); off<dp->size; off+=sizeof(de)){
6408     if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
6409       panic("isdirempty: readi");
6410     if(de.inum != 0)
6411       return 0;
6412   }
6413   return 1;
6414 }
6415 
6416 
6417 
6418 
6419 
6420 
6421 
6422 
6423 
6424 
6425 
6426 
6427 
6428 
6429 
6430 
6431 
6432 
6433 
6434 
6435 
6436 
6437 
6438 
6439 
6440 
6441 
6442 
6443 
6444 
6445 
6446 
6447 
6448 
6449 
6450 int
6451 sys_unlink(void)
6452 {
6453   struct inode *ip, *dp;
6454   struct dirent de;
6455   char name[DIRSIZ], *path;
6456   uint off;
6457 
6458   if(argstr(0, &path) < 0)
6459     return -1;
6460 
6461   begin_op();
6462   if((dp = nameiparent(path, name)) == 0){
6463     end_op();
6464     return -1;
6465   }
6466 
6467   ilock(dp);
6468 
6469   
6470   if(namecmp(name, ".") == 0 || namecmp(name, "..") == 0)
6471     goto bad;
6472 
6473   if((ip = dirlookup(dp, name, &off)) == 0)
6474     goto bad;
6475   ilock(ip);
6476 
6477   if(ip->nlink < 1)
6478     panic("unlink: nlink < 1");
6479   if(ip->type == T_DIR && !isdirempty(ip)){
6480     iunlockput(ip);
6481     goto bad;
6482   }
6483 
6484   memset(&de, 0, sizeof(de));
6485   if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
6486     panic("unlink: writei");
6487   if(ip->type == T_DIR){
6488     dp->nlink--;
6489     iupdate(dp);
6490   }
6491   iunlockput(dp);
6492 
6493   ip->nlink--;
6494   iupdate(ip);
6495   iunlockput(ip);
6496 
6497   end_op();
6498 
6499   return 0;
6500 bad:
6501   iunlockput(dp);
6502   end_op();
6503   return -1;
6504 }
6505 
6506 static struct inode*
6507 create(char *path, short type, short major, short minor)
6508 {
6509   uint off;
6510   struct inode *ip, *dp;
6511   char name[DIRSIZ];
6512 
6513   if((dp = nameiparent(path, name)) == 0)
6514     return 0;
6515   ilock(dp);
6516 
6517   if((ip = dirlookup(dp, name, &off)) != 0){
6518     iunlockput(dp);
6519     ilock(ip);
6520     if(type == T_FILE && ip->type == T_FILE)
6521       return ip;
6522     iunlockput(ip);
6523     return 0;
6524   }
6525 
6526   if((ip = ialloc(dp->dev, type)) == 0)
6527     panic("create: ialloc");
6528 
6529   ilock(ip);
6530   ip->major = major;
6531   ip->minor = minor;
6532   ip->nlink = 1;
6533   iupdate(ip);
6534 
6535   if(type == T_DIR){  
6536     dp->nlink++;  
6537     iupdate(dp);
6538     
6539     if(dirlink(ip, ".", ip->inum) < 0 || dirlink(ip, "..", dp->inum) < 0)
6540       panic("create dots");
6541   }
6542 
6543   if(dirlink(dp, name, ip->inum) < 0)
6544     panic("create: dirlink");
6545 
6546   iunlockput(dp);
6547 
6548   return ip;
6549 }
6550 int
6551 sys_open(void)
6552 {
6553   char *path;
6554   int fd, omode;
6555   struct file *f;
6556   struct inode *ip;
6557 
6558   if(argstr(0, &path) < 0 || argint(1, &omode) < 0)
6559     return -1;
6560 
6561   begin_op();
6562 
6563   if(omode & O_CREATE){
6564     ip = create(path, T_FILE, 0, 0);
6565     if(ip == 0){
6566       end_op();
6567       return -1;
6568     }
6569   } else {
6570     if((ip = namei(path)) == 0){
6571       end_op();
6572       return -1;
6573     }
6574     ilock(ip);
6575     if(ip->type == T_DIR && omode != O_RDONLY){
6576       iunlockput(ip);
6577       end_op();
6578       return -1;
6579     }
6580   }
6581 
6582   if((f = filealloc()) == 0 || (fd = fdalloc(f)) < 0){
6583     if(f)
6584       fileclose(f);
6585     iunlockput(ip);
6586     end_op();
6587     return -1;
6588   }
6589   iunlock(ip);
6590   end_op();
6591 
6592   f->type = FD_INODE;
6593   f->ip = ip;
6594   f->off = 0;
6595   f->readable = !(omode & O_WRONLY);
6596   f->writable = (omode & O_WRONLY) || (omode & O_RDWR);
6597   return fd;
6598 }
6599 
6600 int
6601 sys_mkdir(void)
6602 {
6603   char *path;
6604   struct inode *ip;
6605 
6606   begin_op();
6607   if(argstr(0, &path) < 0 || (ip = create(path, T_DIR, 0, 0)) == 0){
6608     end_op();
6609     return -1;
6610   }
6611   iunlockput(ip);
6612   end_op();
6613   return 0;
6614 }
6615 
6616 int
6617 sys_mknod(void)
6618 {
6619   struct inode *ip;
6620   char *path;
6621   int major, minor;
6622 
6623   begin_op();
6624   if((argstr(0, &path)) < 0 ||
6625      argint(1, &major) < 0 ||
6626      argint(2, &minor) < 0 ||
6627      (ip = create(path, T_DEV, major, minor)) == 0){
6628     end_op();
6629     return -1;
6630   }
6631   iunlockput(ip);
6632   end_op();
6633   return 0;
6634 }
6635 
6636 
6637 
6638 
6639 
6640 
6641 
6642 
6643 
6644 
6645 
6646 
6647 
6648 
6649 
6650 int
6651 sys_chdir(void)
6652 {
6653   char *path;
6654   struct inode *ip;
6655 
6656   begin_op();
6657   if(argstr(0, &path) < 0 || (ip = namei(path)) == 0){
6658     end_op();
6659     return -1;
6660   }
6661   ilock(ip);
6662   if(ip->type != T_DIR){
6663     iunlockput(ip);
6664     end_op();
6665     return -1;
6666   }
6667   iunlock(ip);
6668   iput(proc->cwd);
6669   end_op();
6670   proc->cwd = ip;
6671   return 0;
6672 }
6673 
6674 int
6675 sys_exec(void)
6676 {
6677   char *path, *argv[MAXARG];
6678   int i;
6679   uint uargv, uarg;
6680 
6681   if(argstr(0, &path) < 0 || argint(1, (int*)&uargv) < 0){
6682     return -1;
6683   }
6684   memset(argv, 0, sizeof(argv));
6685   for(i=0;; i++){
6686     if(i >= NELEM(argv))
6687       return -1;
6688     if(fetchint(uargv+4*i, (int*)&uarg) < 0)
6689       return -1;
6690     if(uarg == 0){
6691       argv[i] = 0;
6692       break;
6693     }
6694     if(fetchstr(uarg, &argv[i]) < 0)
6695       return -1;
6696   }
6697   return exec(path, argv);
6698 }
6699 
6700 int
6701 sys_pipe(void)
6702 {
6703   int *fd;
6704   struct file *rf, *wf;
6705   int fd0, fd1;
6706 
6707   if(argptr(0, (void*)&fd, 2*sizeof(fd[0])) < 0)
6708     return -1;
6709   if(pipealloc(&rf, &wf) < 0)
6710     return -1;
6711   fd0 = -1;
6712   if((fd0 = fdalloc(rf)) < 0 || (fd1 = fdalloc(wf)) < 0){
6713     if(fd0 >= 0)
6714       proc->ofile[fd0] = 0;
6715     fileclose(rf);
6716     fileclose(wf);
6717     return -1;
6718   }
6719   fd[0] = fd0;
6720   fd[1] = fd1;
6721   return 0;
6722 }
6723 
6724 
6725 
6726 
6727 
6728 
6729 
6730 
6731 
6732 
6733 
6734 
6735 
6736 
6737 
6738 
6739 
6740 
6741 
6742 
6743 
6744 
6745 
6746 
6747 
6748 
6749 
6750 #include "types.h"
6751 #include "param.h"
6752 #include "memlayout.h"
6753 #include "mmu.h"
6754 #include "proc.h"
6755 #include "defs.h"
6756 #include "x86.h"
6757 #include "elf.h"
6758 
6759 int
6760 exec(char *path, char **argv)
6761 {
6762   char *s, *last;
6763   int i, off;
6764   uint argc, sz, sp, ustack[3+MAXARG+1];
6765   struct elfhdr elf;
6766   struct inode *ip;
6767   struct proghdr ph;
6768   pde_t *pgdir, *oldpgdir;
6769 
6770   begin_op();
6771 
6772   
6773   if((ip = namei(path)) == 0){
6774     end_op();
6775     return -1;
6776   }
6777   ilock(ip);
6778   pgdir = 0;
6779 
6780   
6781   if(readi(ip, (char*)&elf, 0, sizeof(elf)) != sizeof(elf))
6782     goto bad;
6783   if(elf.magic != ELF_MAGIC)
6784     goto bad;
6785 
6786   if((pgdir = setupkvm()) == 0)
6787     goto bad;
6788 
6789   
6790   sz = 0;
6791   
6792   
6793   for(i=0, off=elf.phoff; i<elf.phnum; i++, off+=sizeof(ph)){
6794     if(readi(ip, (char*)&ph, off, sizeof(ph)) != sizeof(ph))
6795       goto bad;
6796     if(ph.type != ELF_PROG_LOAD)
6797       continue;
6798     if(ph.memsz < ph.filesz)
6799       goto bad;
6800     if(ph.vaddr + ph.memsz < ph.vaddr)
6801       goto bad;
6802     if((sz = allocuvm(pgdir, sz, ph.vaddr + ph.memsz)) == 0)
6803       goto bad;
6804     if(ph.vaddr % PGSIZE != 0)
6805       goto bad;
6806     if(loaduvm(pgdir, (char*)ph.vaddr, ip, ph.off, ph.filesz) < 0)
6807       goto bad;
6808   }
6809   iunlockput(ip);
6810   end_op();
6811   ip = 0;
6812 
6813   
6814   
6815   sz = PGROUNDUP(sz);
6816   if((sz = allocuvm(pgdir, sz, sz + 2*PGSIZE)) == 0)
6817     goto bad;
6818   clearpteu(pgdir, (char*)(sz - 2*PGSIZE));
6819   sp = sz;
6820 
6821   
6822   for(argc = 0; argv[argc]; argc++) {
6823     if(argc >= MAXARG)
6824       goto bad;
6825     sp = (sp - (strlen(argv[argc]) + 1)) & ~3;
6826     if(copyout(pgdir, sp, argv[argc], strlen(argv[argc]) + 1) < 0)
6827       goto bad;
6828     ustack[3+argc] = sp;
6829   }
6830   ustack[3+argc] = 0;
6831 
6832   ustack[0] = 0xffffffff;  
6833   ustack[1] = argc;
6834   ustack[2] = sp - (argc+1)*4;  
6835 
6836   sp -= (3+argc+1) * 4;
6837   if(copyout(pgdir, sp, ustack, (3+argc+1)*4) < 0)
6838     goto bad;
6839 
6840   
6841   for(last=s=path; *s; s++)
6842     if(*s == '/')
6843       last = s+1;
6844   safestrcpy(proc->name, last, sizeof(proc->name));
6845 
6846 
6847 
6848 
6849 
6850   
6851   oldpgdir = proc->pgdir;
6852   proc->pgdir = pgdir;
6853   proc->sz = sz;
6854   proc->tf->eip = elf.entry;  
6855   proc->tf->esp = sp;
6856   switchuvm(proc);
6857   freevm(oldpgdir);
6858   return 0;
6859 
6860  bad:
6861   if(pgdir)
6862     freevm(pgdir);
6863   if(ip){
6864     iunlockput(ip);
6865     end_op();
6866   }
6867   return -1;
6868 }
6869 
6870 
6871 
6872 
6873 
6874 
6875 
6876 
6877 
6878 
6879 
6880 
6881 
6882 
6883 
6884 
6885 
6886 
6887 
6888 
6889 
6890 
6891 
6892 
6893 
6894 
6895 
6896 
6897 
6898 
6899 
6900 #include "types.h"
6901 #include "defs.h"
6902 #include "param.h"
6903 #include "mmu.h"
6904 #include "proc.h"
6905 #include "fs.h"
6906 #include "spinlock.h"
6907 #include "sleeplock.h"
6908 #include "file.h"
6909 
6910 #define PIPESIZE 512
6911 
6912 struct pipe {
6913   struct spinlock lock;
6914   char data[PIPESIZE];
6915   uint nread;     
6916   uint nwrite;    
6917   int readopen;   
6918   int writeopen;  
6919 };
6920 
6921 int
6922 pipealloc(struct file **f0, struct file **f1)
6923 {
6924   struct pipe *p;
6925 
6926   p = 0;
6927   *f0 = *f1 = 0;
6928   if((*f0 = filealloc()) == 0 || (*f1 = filealloc()) == 0)
6929     goto bad;
6930   if((p = (struct pipe*)kalloc()) == 0)
6931     goto bad;
6932   p->readopen = 1;
6933   p->writeopen = 1;
6934   p->nwrite = 0;
6935   p->nread = 0;
6936   initlock(&p->lock, "pipe");
6937   (*f0)->type = FD_PIPE;
6938   (*f0)->readable = 1;
6939   (*f0)->writable = 0;
6940   (*f0)->pipe = p;
6941   (*f1)->type = FD_PIPE;
6942   (*f1)->readable = 0;
6943   (*f1)->writable = 1;
6944   (*f1)->pipe = p;
6945   return 0;
6946 
6947 
6948 
6949 
6950  bad:
6951   if(p)
6952     kfree((char*)p);
6953   if(*f0)
6954     fileclose(*f0);
6955   if(*f1)
6956     fileclose(*f1);
6957   return -1;
6958 }
6959 
6960 void
6961 pipeclose(struct pipe *p, int writable)
6962 {
6963   acquire(&p->lock);
6964   if(writable){
6965     p->writeopen = 0;
6966     wakeup(&p->nread);
6967   } else {
6968     p->readopen = 0;
6969     wakeup(&p->nwrite);
6970   }
6971   if(p->readopen == 0 && p->writeopen == 0){
6972     release(&p->lock);
6973     kfree((char*)p);
6974   } else
6975     release(&p->lock);
6976 }
6977 
6978 
6979 int
6980 pipewrite(struct pipe *p, char *addr, int n)
6981 {
6982   int i;
6983 
6984   acquire(&p->lock);
6985   for(i = 0; i < n; i++){
6986     while(p->nwrite == p->nread + PIPESIZE){  
6987       if(p->readopen == 0 || proc->killed){
6988         release(&p->lock);
6989         return -1;
6990       }
6991       wakeup(&p->nread);
6992       sleep(&p->nwrite, &p->lock);  
6993     }
6994     p->data[p->nwrite++ % PIPESIZE] = addr[i];
6995   }
6996   wakeup(&p->nread);  
6997   release(&p->lock);
6998   return n;
6999 }
7000 int
7001 piperead(struct pipe *p, char *addr, int n)
7002 {
7003   int i;
7004 
7005   acquire(&p->lock);
7006   while(p->nread == p->nwrite && p->writeopen){  
7007     if(proc->killed){
7008       release(&p->lock);
7009       return -1;
7010     }
7011     sleep(&p->nread, &p->lock); 
7012   }
7013   for(i = 0; i < n; i++){  
7014     if(p->nread == p->nwrite)
7015       break;
7016     addr[i] = p->data[p->nread++ % PIPESIZE];
7017   }
7018   wakeup(&p->nwrite);  
7019   release(&p->lock);
7020   return i;
7021 }
7022 
7023 
7024 
7025 
7026 
7027 
7028 
7029 
7030 
7031 
7032 
7033 
7034 
7035 
7036 
7037 
7038 
7039 
7040 
7041 
7042 
7043 
7044 
7045 
7046 
7047 
7048 
7049 
7050 #include "types.h"
7051 #include "x86.h"
7052 
7053 void*
7054 memset(void *dst, int c, uint n)
7055 {
7056   if ((int)dst%4 == 0 && n%4 == 0){
7057     c &= 0xFF;
7058     stosl(dst, (c<<24)|(c<<16)|(c<<8)|c, n/4);
7059   } else
7060     stosb(dst, c, n);
7061   return dst;
7062 }
7063 
7064 int
7065 memcmp(const void *v1, const void *v2, uint n)
7066 {
7067   const uchar *s1, *s2;
7068 
7069   s1 = v1;
7070   s2 = v2;
7071   while(n-- > 0){
7072     if(*s1 != *s2)
7073       return *s1 - *s2;
7074     s1++, s2++;
7075   }
7076 
7077   return 0;
7078 }
7079 
7080 void*
7081 memmove(void *dst, const void *src, uint n)
7082 {
7083   const char *s;
7084   char *d;
7085 
7086   s = src;
7087   d = dst;
7088   if(s < d && s + n > d){
7089     s += n;
7090     d += n;
7091     while(n-- > 0)
7092       *--d = *--s;
7093   } else
7094     while(n-- > 0)
7095       *d++ = *s++;
7096 
7097   return dst;
7098 }
7099 
7100 
7101 void*
7102 memcpy(void *dst, const void *src, uint n)
7103 {
7104   return memmove(dst, src, n);
7105 }
7106 
7107 int
7108 strncmp(const char *p, const char *q, uint n)
7109 {
7110   while(n > 0 && *p && *p == *q)
7111     n--, p++, q++;
7112   if(n == 0)
7113     return 0;
7114   return (uchar)*p - (uchar)*q;
7115 }
7116 
7117 char*
7118 strncpy(char *s, const char *t, int n)
7119 {
7120   char *os;
7121 
7122   os = s;
7123   while(n-- > 0 && (*s++ = *t++) != 0)
7124     ;
7125   while(n-- > 0)
7126     *s++ = 0;
7127   return os;
7128 }
7129 
7130 
7131 char*
7132 safestrcpy(char *s, const char *t, int n)
7133 {
7134   char *os;
7135 
7136   os = s;
7137   if(n <= 0)
7138     return os;
7139   while(--n > 0 && (*s++ = *t++) != 0)
7140     ;
7141   *s = 0;
7142   return os;
7143 }
7144 
7145 
7146 
7147 
7148 
7149 
7150 int
7151 strlen(const char *s)
7152 {
7153   int n;
7154 
7155   for(n = 0; s[n]; n++)
7156     ;
7157   return n;
7158 }
7159 
7160 
7161 
7162 
7163 
7164 
7165 
7166 
7167 
7168 
7169 
7170 
7171 
7172 
7173 
7174 
7175 
7176 
7177 
7178 
7179 
7180 
7181 
7182 
7183 
7184 
7185 
7186 
7187 
7188 
7189 
7190 
7191 
7192 
7193 
7194 
7195 
7196 
7197 
7198 
7199 
7200 
7201 
7202 struct mp {             
7203   uchar signature[4];           
7204   void *physaddr;               
7205   uchar length;                 
7206   uchar specrev;                
7207   uchar checksum;               
7208   uchar type;                   
7209   uchar imcrp;
7210   uchar reserved[3];
7211 };
7212 
7213 struct mpconf {         
7214   uchar signature[4];           
7215   ushort length;                
7216   uchar version;                
7217   uchar checksum;               
7218   uchar product[20];            
7219   uint *oemtable;               
7220   ushort oemlength;             
7221   ushort entry;                 
7222   uint *lapicaddr;              
7223   ushort xlength;               
7224   uchar xchecksum;              
7225   uchar reserved;
7226 };
7227 
7228 struct mpproc {         
7229   uchar type;                   
7230   uchar apicid;                 
7231   uchar version;                
7232   uchar flags;                  
7233     #define MPBOOT 0x02           
7234   uchar signature[4];           
7235   uint feature;                 
7236   uchar reserved[8];
7237 };
7238 
7239 struct mpioapic {       
7240   uchar type;                   
7241   uchar apicno;                 
7242   uchar version;                
7243   uchar flags;                  
7244   uint *addr;                  
7245 };
7246 
7247 
7248 
7249 
7250 
7251 #define MPPROC    0x00  
7252 #define MPBUS     0x01  
7253 #define MPIOAPIC  0x02  
7254 #define MPIOINTR  0x03  
7255 #define MPLINTR   0x04  
7256 
7257 
7258 
7259 
7260 
7261 
7262 
7263 
7264 
7265 
7266 
7267 
7268 
7269 
7270 
7271 
7272 
7273 
7274 
7275 
7276 
7277 
7278 
7279 
7280 
7281 
7282 
7283 
7284 
7285 
7286 
7287 
7288 
7289 
7290 
7291 
7292 
7293 
7294 
7295 
7296 
7297 
7298 
7299 
7300 
7301 
7302 
7303 
7304 
7305 
7306 
7307 
7308 
7309 
7310 
7311 
7312 
7313 
7314 
7315 
7316 
7317 
7318 
7319 
7320 
7321 
7322 
7323 
7324 
7325 
7326 
7327 
7328 
7329 
7330 
7331 
7332 
7333 
7334 
7335 
7336 
7337 
7338 
7339 
7340 
7341 
7342 
7343 
7344 
7345 
7346 
7347 
7348 
7349 
7350 
7351 
7352 
7353 
7354 #include "types.h"
7355 #include "defs.h"
7356 #include "param.h"
7357 #include "memlayout.h"
7358 #include "mp.h"
7359 #include "x86.h"
7360 #include "mmu.h"
7361 #include "proc.h"
7362 
7363 struct cpu cpus[NCPU];
7364 int ismp;
7365 int ncpu;
7366 uchar ioapicid;
7367 
7368 static uchar
7369 sum(uchar *addr, int len)
7370 {
7371   int i, sum;
7372 
7373   sum = 0;
7374   for(i=0; i<len; i++)
7375     sum += addr[i];
7376   return sum;
7377 }
7378 
7379 
7380 static struct mp*
7381 mpsearch1(uint a, int len)
7382 {
7383   uchar *e, *p, *addr;
7384 
7385   addr = P2V(a);
7386   e = addr+len;
7387   for(p = addr; p < e; p += sizeof(struct mp))
7388     if(memcmp(p, "_MP_", 4) == 0 && sum(p, sizeof(struct mp)) == 0)
7389       return (struct mp*)p;
7390   return 0;
7391 }
7392 
7393 
7394 
7395 
7396 
7397 
7398 
7399 
7400 
7401 
7402 
7403 
7404 
7405 static struct mp*
7406 mpsearch(void)
7407 {
7408   uchar *bda;
7409   uint p;
7410   struct mp *mp;
7411 
7412   bda = (uchar *) P2V(0x400);
7413   if((p = ((bda[0x0F]<<8)| bda[0x0E]) << 4)){
7414     if((mp = mpsearch1(p, 1024)))
7415       return mp;
7416   } else {
7417     p = ((bda[0x14]<<8)|bda[0x13])*1024;
7418     if((mp = mpsearch1(p-1024, 1024)))
7419       return mp;
7420   }
7421   return mpsearch1(0xF0000, 0x10000);
7422 }
7423 
7424 
7425 
7426 
7427 
7428 
7429 static struct mpconf*
7430 mpconfig(struct mp **pmp)
7431 {
7432   struct mpconf *conf;
7433   struct mp *mp;
7434 
7435   if((mp = mpsearch()) == 0 || mp->physaddr == 0)
7436     return 0;
7437   conf = (struct mpconf*) P2V((uint) mp->physaddr);
7438   if(memcmp(conf, "PCMP", 4) != 0)
7439     return 0;
7440   if(conf->version != 1 && conf->version != 4)
7441     return 0;
7442   if(sum((uchar*)conf, conf->length) != 0)
7443     return 0;
7444   *pmp = mp;
7445   return conf;
7446 }
7447 
7448 
7449 
7450 void
7451 mpinit(void)
7452 {
7453   uchar *p, *e;
7454   struct mp *mp;
7455   struct mpconf *conf;
7456   struct mpproc *proc;
7457   struct mpioapic *ioapic;
7458 
7459   if((conf = mpconfig(&mp)) == 0)
7460     return;
7461   ismp = 1;
7462   lapic = (uint*)conf->lapicaddr;
7463   for(p=(uchar*)(conf+1), e=(uchar*)conf+conf->length; p<e; ){
7464     switch(*p){
7465     case MPPROC:
7466       proc = (struct mpproc*)p;
7467       if(ncpu < NCPU) {
7468         cpus[ncpu].apicid = proc->apicid;  
7469         ncpu++;
7470       }
7471       p += sizeof(struct mpproc);
7472       continue;
7473     case MPIOAPIC:
7474       ioapic = (struct mpioapic*)p;
7475       ioapicid = ioapic->apicno;
7476       p += sizeof(struct mpioapic);
7477       continue;
7478     case MPBUS:
7479     case MPIOINTR:
7480     case MPLINTR:
7481       p += 8;
7482       continue;
7483     default:
7484       ismp = 0;
7485       break;
7486     }
7487   }
7488   if(!ismp){
7489     
7490     ncpu = 1;
7491     lapic = 0;
7492     ioapicid = 0;
7493     return;
7494   }
7495 
7496 
7497 
7498 
7499 
7500   if(mp->imcrp){
7501     
7502     
7503     outb(0x22, 0x70);   
7504     outb(0x23, inb(0x23) | 1);  
7505   }
7506 }
7507 
7508 
7509 
7510 
7511 
7512 
7513 
7514 
7515 
7516 
7517 
7518 
7519 
7520 
7521 
7522 
7523 
7524 
7525 
7526 
7527 
7528 
7529 
7530 
7531 
7532 
7533 
7534 
7535 
7536 
7537 
7538 
7539 
7540 
7541 
7542 
7543 
7544 
7545 
7546 
7547 
7548 
7549 
7550 
7551 
7552 
7553 #include "param.h"
7554 #include "types.h"
7555 #include "defs.h"
7556 #include "date.h"
7557 #include "memlayout.h"
7558 #include "traps.h"
7559 #include "mmu.h"
7560 #include "x86.h"
7561 #include "proc.h"  
7562 
7563 
7564 #define ID      (0x0020/4)   
7565 #define VER     (0x0030/4)   
7566 #define TPR     (0x0080/4)   
7567 #define EOI     (0x00B0/4)   
7568 #define SVR     (0x00F0/4)   
7569   #define ENABLE     0x00000100   
7570 #define ESR     (0x0280/4)   
7571 #define ICRLO   (0x0300/4)   
7572   #define INIT       0x00000500   
7573   #define STARTUP    0x00000600   
7574   #define DELIVS     0x00001000   
7575   #define ASSERT     0x00004000   
7576   #define DEASSERT   0x00000000
7577   #define LEVEL      0x00008000   
7578   #define BCAST      0x00080000   
7579   #define BUSY       0x00001000
7580   #define FIXED      0x00000000
7581 #define ICRHI   (0x0310/4)   
7582 #define TIMER   (0x0320/4)   
7583   #define X1         0x0000000B   
7584   #define PERIODIC   0x00020000   
7585 #define PCINT   (0x0340/4)   
7586 #define LINT0   (0x0350/4)   
7587 #define LINT1   (0x0360/4)   
7588 #define ERROR   (0x0370/4)   
7589   #define MASKED     0x00010000   
7590 #define TICR    (0x0380/4)   
7591 #define TCCR    (0x0390/4)   
7592 #define TDCR    (0x03E0/4)   
7593 
7594 volatile uint *lapic;  
7595 
7596 
7597 
7598 
7599 
7600 static void
7601 lapicw(int index, int value)
7602 {
7603   lapic[index] = value;
7604   lapic[ID];  
7605 }
7606 
7607 
7608 
7609 
7610 
7611 
7612 
7613 
7614 
7615 
7616 
7617 
7618 
7619 
7620 
7621 
7622 
7623 
7624 
7625 
7626 
7627 
7628 
7629 
7630 
7631 
7632 
7633 
7634 
7635 
7636 
7637 
7638 
7639 
7640 
7641 
7642 
7643 
7644 
7645 
7646 
7647 
7648 
7649 
7650 void
7651 lapicinit(void)
7652 {
7653   if(!lapic)
7654     return;
7655 
7656   
7657   lapicw(SVR, ENABLE | (T_IRQ0 + IRQ_SPURIOUS));
7658 
7659   
7660   
7661   
7662   
7663   lapicw(TDCR, X1);
7664   lapicw(TIMER, PERIODIC | (T_IRQ0 + IRQ_TIMER));
7665   lapicw(TICR, 10000000);
7666 
7667   
7668   lapicw(LINT0, MASKED);
7669   lapicw(LINT1, MASKED);
7670 
7671   
7672   
7673   if(((lapic[VER]>>16) & 0xFF) >= 4)
7674     lapicw(PCINT, MASKED);
7675 
7676   
7677   lapicw(ERROR, T_IRQ0 + IRQ_ERROR);
7678 
7679   
7680   lapicw(ESR, 0);
7681   lapicw(ESR, 0);
7682 
7683   
7684   lapicw(EOI, 0);
7685 
7686   
7687   lapicw(ICRHI, 0);
7688   lapicw(ICRLO, BCAST | INIT | LEVEL);
7689   while(lapic[ICRLO] & DELIVS)
7690     ;
7691 
7692   
7693   lapicw(TPR, 0);
7694 }
7695 
7696 
7697 
7698 
7699 
7700 int
7701 cpunum(void)
7702 {
7703   int apicid, i;
7704 
7705   
7706   
7707   
7708   
7709   
7710   if(readeflags()&FL_IF){
7711     static int n;
7712     if(n++ == 0)
7713       cprintf("cpu called from %x with interrupts enabled\n",
7714         __builtin_return_address(0));
7715   }
7716 
7717   if (!lapic)
7718     return 0;
7719 
7720   apicid = lapic[ID] >> 24;
7721   for (i = 0; i < ncpu; ++i) {
7722     if (cpus[i].apicid == apicid)
7723       return i;
7724   }
7725   panic("unknown apicid\n");
7726 }
7727 
7728 
7729 void
7730 lapiceoi(void)
7731 {
7732   if(lapic)
7733     lapicw(EOI, 0);
7734 }
7735 
7736 
7737 
7738 void
7739 microdelay(int us)
7740 {
7741 }
7742 
7743 
7744 
7745 
7746 
7747 
7748 
7749 
7750 #define CMOS_PORT    0x70
7751 #define CMOS_RETURN  0x71
7752 
7753 
7754 
7755 void
7756 lapicstartap(uchar apicid, uint addr)
7757 {
7758   int i;
7759   ushort *wrv;
7760 
7761   
7762   
7763   
7764   outb(CMOS_PORT, 0xF);  
7765   outb(CMOS_PORT+1, 0x0A);
7766   wrv = (ushort*)P2V((0x40<<4 | 0x67));  
7767   wrv[0] = 0;
7768   wrv[1] = addr >> 4;
7769 
7770   
7771   
7772   lapicw(ICRHI, apicid<<24);
7773   lapicw(ICRLO, INIT | LEVEL | ASSERT);
7774   microdelay(200);
7775   lapicw(ICRLO, INIT | LEVEL);
7776   microdelay(100);    
7777 
7778   
7779   
7780   
7781   
7782   
7783   for(i = 0; i < 2; i++){
7784     lapicw(ICRHI, apicid<<24);
7785     lapicw(ICRLO, STARTUP | (addr>>12));
7786     microdelay(200);
7787   }
7788 }
7789 
7790 
7791 
7792 
7793 
7794 
7795 
7796 
7797 
7798 
7799 
7800 #define CMOS_STATA   0x0a
7801 #define CMOS_STATB   0x0b
7802 #define CMOS_UIP    (1 << 7)        
7803 
7804 #define SECS    0x00
7805 #define MINS    0x02
7806 #define HOURS   0x04
7807 #define DAY     0x07
7808 #define MONTH   0x08
7809 #define YEAR    0x09
7810 
7811 static uint cmos_read(uint reg)
7812 {
7813   outb(CMOS_PORT,  reg);
7814   microdelay(200);
7815 
7816   return inb(CMOS_RETURN);
7817 }
7818 
7819 static void fill_rtcdate(struct rtcdate *r)
7820 {
7821   r->second = cmos_read(SECS);
7822   r->minute = cmos_read(MINS);
7823   r->hour   = cmos_read(HOURS);
7824   r->day    = cmos_read(DAY);
7825   r->month  = cmos_read(MONTH);
7826   r->year   = cmos_read(YEAR);
7827 }
7828 
7829 
7830 void cmostime(struct rtcdate *r)
7831 {
7832   struct rtcdate t1, t2;
7833   int sb, bcd;
7834 
7835   sb = cmos_read(CMOS_STATB);
7836 
7837   bcd = (sb & (1 << 2)) == 0;
7838 
7839   
7840   for(;;) {
7841     fill_rtcdate(&t1);
7842     if(cmos_read(CMOS_STATA) & CMOS_UIP)
7843         continue;
7844     fill_rtcdate(&t2);
7845     if(memcmp(&t1, &t2, sizeof(t1)) == 0)
7846       break;
7847   }
7848 
7849 
7850   
7851   if(bcd) {
7852 #define    CONV(x)     (t1.x = ((t1.x >> 4) * 10) + (t1.x & 0xf))
7853     CONV(second);
7854     CONV(minute);
7855     CONV(hour  );
7856     CONV(day   );
7857     CONV(month );
7858     CONV(year  );
7859 #undef     CONV
7860   }
7861 
7862   *r = t1;
7863   r->year += 2000;
7864 }
7865 
7866 
7867 
7868 
7869 
7870 
7871 
7872 
7873 
7874 
7875 
7876 
7877 
7878 
7879 
7880 
7881 
7882 
7883 
7884 
7885 
7886 
7887 
7888 
7889 
7890 
7891 
7892 
7893 
7894 
7895 
7896 
7897 
7898 
7899 
7900 
7901 
7902 
7903 
7904 #include "types.h"
7905 #include "defs.h"
7906 #include "traps.h"
7907 
7908 #define IOAPIC  0xFEC00000   
7909 
7910 #define REG_ID     0x00  
7911 #define REG_VER    0x01  
7912 #define REG_TABLE  0x10  
7913 
7914 
7915 
7916 
7917 
7918 
7919 #define INT_DISABLED   0x00010000  
7920 #define INT_LEVEL      0x00008000  
7921 #define INT_ACTIVELOW  0x00002000  
7922 #define INT_LOGICAL    0x00000800  
7923 
7924 volatile struct ioapic *ioapic;
7925 
7926 
7927 struct ioapic {
7928   uint reg;
7929   uint pad[3];
7930   uint data;
7931 };
7932 
7933 static uint
7934 ioapicread(int reg)
7935 {
7936   ioapic->reg = reg;
7937   return ioapic->data;
7938 }
7939 
7940 static void
7941 ioapicwrite(int reg, uint data)
7942 {
7943   ioapic->reg = reg;
7944   ioapic->data = data;
7945 }
7946 
7947 
7948 
7949 
7950 void
7951 ioapicinit(void)
7952 {
7953   int i, id, maxintr;
7954 
7955   if(!ismp)
7956     return;
7957 
7958   ioapic = (volatile struct ioapic*)IOAPIC;
7959   maxintr = (ioapicread(REG_VER) >> 16) & 0xFF;
7960   id = ioapicread(REG_ID) >> 24;
7961   if(id != ioapicid)
7962     cprintf("ioapicinit: id isn't equal to ioapicid; not a MP\n");
7963 
7964   
7965   
7966   for(i = 0; i <= maxintr; i++){
7967     ioapicwrite(REG_TABLE+2*i, INT_DISABLED | (T_IRQ0 + i));
7968     ioapicwrite(REG_TABLE+2*i+1, 0);
7969   }
7970 }
7971 
7972 void
7973 ioapicenable(int irq, int cpunum)
7974 {
7975   if(!ismp)
7976     return;
7977 
7978   
7979   
7980   
7981   ioapicwrite(REG_TABLE+2*irq, T_IRQ0 + irq);
7982   ioapicwrite(REG_TABLE+2*irq+1, cpunum << 24);
7983 }
7984 
7985 
7986 
7987 
7988 
7989 
7990 
7991 
7992 
7993 
7994 
7995 
7996 
7997 
7998 
7999 
8000 
8001 
8002 #include "types.h"
8003 #include "x86.h"
8004 #include "traps.h"
8005 
8006 
8007 #define IO_PIC1         0x20    
8008 #define IO_PIC2         0xA0    
8009 
8010 #define IRQ_SLAVE       2       
8011 
8012 
8013 
8014 static ushort irqmask = 0xFFFF & ~(1<<IRQ_SLAVE);
8015 
8016 static void
8017 picsetmask(ushort mask)
8018 {
8019   irqmask = mask;
8020   outb(IO_PIC1+1, mask);
8021   outb(IO_PIC2+1, mask >> 8);
8022 }
8023 
8024 void
8025 picenable(int irq)
8026 {
8027   picsetmask(irqmask & ~(1<<irq));
8028 }
8029 
8030 
8031 void
8032 picinit(void)
8033 {
8034   
8035   outb(IO_PIC1+1, 0xFF);
8036   outb(IO_PIC2+1, 0xFF);
8037 
8038   
8039 
8040   
8041   
8042   
8043   
8044   outb(IO_PIC1, 0x11);
8045 
8046   
8047   outb(IO_PIC1+1, T_IRQ0);
8048 
8049 
8050   
8051   
8052   outb(IO_PIC1+1, 1<<IRQ_SLAVE);
8053 
8054   
8055   
8056   
8057   
8058   
8059   
8060   
8061   
8062   outb(IO_PIC1+1, 0x3);
8063 
8064   
8065   outb(IO_PIC2, 0x11);                  
8066   outb(IO_PIC2+1, T_IRQ0 + 8);      
8067   outb(IO_PIC2+1, IRQ_SLAVE);           
8068   
8069   
8070   outb(IO_PIC2+1, 0x3);                 
8071 
8072   
8073   
8074   
8075   
8076   outb(IO_PIC1, 0x68);             
8077   outb(IO_PIC1, 0x0a);             
8078 
8079   outb(IO_PIC2, 0x68);             
8080   outb(IO_PIC2, 0x0a);             
8081 
8082   if(irqmask != 0xFFFF)
8083     picsetmask(irqmask);
8084 }
8085 
8086 
8087 
8088 
8089 
8090 
8091 
8092 
8093 
8094 
8095 
8096 
8097 
8098 
8099 
8100 
8101 
8102 
8103 
8104 
8105 
8106 
8107 
8108 
8109 
8110 
8111 
8112 
8113 
8114 
8115 
8116 
8117 
8118 
8119 
8120 
8121 
8122 
8123 
8124 
8125 
8126 
8127 
8128 
8129 
8130 
8131 
8132 
8133 
8134 
8135 
8136 
8137 
8138 
8139 
8140 
8141 
8142 
8143 
8144 
8145 
8146 
8147 
8148 
8149 
8150 
8151 
8152 #define KBSTATP         0x64    
8153 #define KBS_DIB         0x01    
8154 #define KBDATAP         0x60    
8155 
8156 #define NO              0
8157 
8158 #define SHIFT           (1<<0)
8159 #define CTL             (1<<1)
8160 #define ALT             (1<<2)
8161 
8162 #define CAPSLOCK        (1<<3)
8163 #define NUMLOCK         (1<<4)
8164 #define SCROLLLOCK      (1<<5)
8165 
8166 #define E0ESC           (1<<6)
8167 
8168 
8169 #define KEY_HOME        0xE0
8170 #define KEY_END         0xE1
8171 #define KEY_UP          0xE2
8172 #define KEY_DN          0xE3
8173 #define KEY_LF          0xE4
8174 #define KEY_RT          0xE5
8175 #define KEY_PGUP        0xE6
8176 #define KEY_PGDN        0xE7
8177 #define KEY_INS         0xE8
8178 #define KEY_DEL         0xE9
8179 
8180 
8181 #define C(x) (x - '@')
8182 
8183 static uchar shiftcode[256] =
8184 {
8185   [0x1D] CTL,
8186   [0x2A] SHIFT,
8187   [0x36] SHIFT,
8188   [0x38] ALT,
8189   [0x9D] CTL,
8190   [0xB8] ALT
8191 };
8192 
8193 static uchar togglecode[256] =
8194 {
8195   [0x3A] CAPSLOCK,
8196   [0x45] NUMLOCK,
8197   [0x46] SCROLLLOCK
8198 };
8199 
8200 static uchar normalmap[256] =
8201 {
8202   NO,   0x1B, '1',  '2',  '3',  '4',  '5',  '6',  
8203   '7',  '8',  '9',  '0',  '-',  '=',  '\b', '\t',
8204   'q',  'w',  'e',  'r',  't',  'y',  'u',  'i',  
8205   'o',  'p',  '[',  ']',  '\n', NO,   'a',  's',
8206   'd',  'f',  'g',  'h',  'j',  'k',  'l',  ';',  
8207   '\'', '`',  NO,   '\\', 'z',  'x',  'c',  'v',
8208   'b',  'n',  'm',  ',',  '.',  '/',  NO,   '*',  
8209   NO,   ' ',  NO,   NO,   NO,   NO,   NO,   NO,
8210   NO,   NO,   NO,   NO,   NO,   NO,   NO,   '7',  
8211   '8',  '9',  '-',  '4',  '5',  '6',  '+',  '1',
8212   '2',  '3',  '0',  '.',  NO,   NO,   NO,   NO,   
8213   [0x9C] '\n',      
8214   [0xB5] '/',       
8215   [0xC8] KEY_UP,    [0xD0] KEY_DN,
8216   [0xC9] KEY_PGUP,  [0xD1] KEY_PGDN,
8217   [0xCB] KEY_LF,    [0xCD] KEY_RT,
8218   [0x97] KEY_HOME,  [0xCF] KEY_END,
8219   [0xD2] KEY_INS,   [0xD3] KEY_DEL
8220 };
8221 
8222 static uchar shiftmap[256] =
8223 {
8224   NO,   033,  '!',  '@',  '#',  '$',  '%',  '^',  
8225   '&',  '*',  '(',  ')',  '_',  '+',  '\b', '\t',
8226   'Q',  'W',  'E',  'R',  'T',  'Y',  'U',  'I',  
8227   'O',  'P',  '{',  '}',  '\n', NO,   'A',  'S',
8228   'D',  'F',  'G',  'H',  'J',  'K',  'L',  ':',  
8229   '"',  '~',  NO,   '|',  'Z',  'X',  'C',  'V',
8230   'B',  'N',  'M',  '<',  '>',  '?',  NO,   '*',  
8231   NO,   ' ',  NO,   NO,   NO,   NO,   NO,   NO,
8232   NO,   NO,   NO,   NO,   NO,   NO,   NO,   '7',  
8233   '8',  '9',  '-',  '4',  '5',  '6',  '+',  '1',
8234   '2',  '3',  '0',  '.',  NO,   NO,   NO,   NO,   
8235   [0x9C] '\n',      
8236   [0xB5] '/',       
8237   [0xC8] KEY_UP,    [0xD0] KEY_DN,
8238   [0xC9] KEY_PGUP,  [0xD1] KEY_PGDN,
8239   [0xCB] KEY_LF,    [0xCD] KEY_RT,
8240   [0x97] KEY_HOME,  [0xCF] KEY_END,
8241   [0xD2] KEY_INS,   [0xD3] KEY_DEL
8242 };
8243 
8244 
8245 
8246 
8247 
8248 
8249 
8250 static uchar ctlmap[256] =
8251 {
8252   NO,      NO,      NO,      NO,      NO,      NO,      NO,      NO,
8253   NO,      NO,      NO,      NO,      NO,      NO,      NO,      NO,
8254   C('Q'),  C('W'),  C('E'),  C('R'),  C('T'),  C('Y'),  C('U'),  C('I'),
8255   C('O'),  C('P'),  NO,      NO,      '\r',    NO,      C('A'),  C('S'),
8256   C('D'),  C('F'),  C('G'),  C('H'),  C('J'),  C('K'),  C('L'),  NO,
8257   NO,      NO,      NO,      C('\\'), C('Z'),  C('X'),  C('C'),  C('V'),
8258   C('B'),  C('N'),  C('M'),  NO,      NO,      C('/'),  NO,      NO,
8259   [0x9C] '\r',      
8260   [0xB5] C('/'),    
8261   [0xC8] KEY_UP,    [0xD0] KEY_DN,
8262   [0xC9] KEY_PGUP,  [0xD1] KEY_PGDN,
8263   [0xCB] KEY_LF,    [0xCD] KEY_RT,
8264   [0x97] KEY_HOME,  [0xCF] KEY_END,
8265   [0xD2] KEY_INS,   [0xD3] KEY_DEL
8266 };
8267 
8268 
8269 
8270 
8271 
8272 
8273 
8274 
8275 
8276 
8277 
8278 
8279 
8280 
8281 
8282 
8283 
8284 
8285 
8286 
8287 
8288 
8289 
8290 
8291 
8292 
8293 
8294 
8295 
8296 
8297 
8298 
8299 
8300 #include "types.h"
8301 #include "x86.h"
8302 #include "defs.h"
8303 #include "kbd.h"
8304 
8305 int
8306 kbdgetc(void)
8307 {
8308   static uint shift;
8309   static uchar *charcode[4] = {
8310     normalmap, shiftmap, ctlmap, ctlmap
8311   };
8312   uint st, data, c;
8313 
8314   st = inb(KBSTATP);
8315   if((st & KBS_DIB) == 0)
8316     return -1;
8317   data = inb(KBDATAP);
8318 
8319   if(data == 0xE0){
8320     shift |= E0ESC;
8321     return 0;
8322   } else if(data & 0x80){
8323     
8324     data = (shift & E0ESC ? data : data & 0x7F);
8325     shift &= ~(shiftcode[data] | E0ESC);
8326     return 0;
8327   } else if(shift & E0ESC){
8328     
8329     data |= 0x80;
8330     shift &= ~E0ESC;
8331   }
8332 
8333   shift |= shiftcode[data];
8334   shift ^= togglecode[data];
8335   c = charcode[shift & (CTL | SHIFT)][data];
8336   if(shift & CAPSLOCK){
8337     if('a' <= c && c <= 'z')
8338       c += 'A' - 'a';
8339     else if('A' <= c && c <= 'Z')
8340       c += 'a' - 'A';
8341   }
8342   return c;
8343 }
8344 
8345 void
8346 kbdintr(void)
8347 {
8348   consoleintr(kbdgetc);
8349 }
8350 
8351 
8352 
8353 
8354 #include "types.h"
8355 #include "defs.h"
8356 #include "param.h"
8357 #include "traps.h"
8358 #include "spinlock.h"
8359 #include "sleeplock.h"
8360 #include "fs.h"
8361 #include "file.h"
8362 #include "memlayout.h"
8363 #include "mmu.h"
8364 #include "proc.h"
8365 #include "x86.h"
8366 
8367 static void consputc(int);
8368 
8369 static int panicked = 0;
8370 
8371 static struct {
8372   struct spinlock lock;
8373   int locking;
8374 } cons;
8375 
8376 static void
8377 printint(int xx, int base, int sign)
8378 {
8379   static char digits[] = "0123456789abcdef";
8380   char buf[16];
8381   int i;
8382   uint x;
8383 
8384   if(sign && (sign = xx < 0))
8385     x = -xx;
8386   else
8387     x = xx;
8388 
8389   i = 0;
8390   do{
8391     buf[i++] = digits[x % base];
8392   }while((x /= base) != 0);
8393 
8394   if(sign)
8395     buf[i++] = '-';
8396 
8397   while(--i >= 0)
8398     consputc(buf[i]);
8399 }
8400 
8401 
8402 
8403 
8404 
8405 
8406 
8407 
8408 
8409 
8410 
8411 
8412 
8413 
8414 
8415 
8416 
8417 
8418 
8419 
8420 
8421 
8422 
8423 
8424 
8425 
8426 
8427 
8428 
8429 
8430 
8431 
8432 
8433 
8434 
8435 
8436 
8437 
8438 
8439 
8440 
8441 
8442 
8443 
8444 
8445 
8446 
8447 
8448 
8449 
8450 
8451 void
8452 cprintf(char *fmt, ...)
8453 {
8454   int i, c, locking;
8455   uint *argp;
8456   char *s;
8457 
8458   locking = cons.locking;
8459   if(locking)
8460     acquire(&cons.lock);
8461 
8462   if (fmt == 0)
8463     panic("null fmt");
8464 
8465   argp = (uint*)(void*)(&fmt + 1);
8466   for(i = 0; (c = fmt[i] & 0xff) != 0; i++){
8467     if(c != '%'){
8468       consputc(c);
8469       continue;
8470     }
8471     c = fmt[++i] & 0xff;
8472     if(c == 0)
8473       break;
8474     switch(c){
8475     case 'd':
8476       printint(*argp++, 10, 1);
8477       break;
8478     case 'x':
8479     case 'p':
8480       printint(*argp++, 16, 0);
8481       break;
8482     case 's':
8483       if((s = (char*)*argp++) == 0)
8484         s = "(null)";
8485       for(; *s; s++)
8486         consputc(*s);
8487       break;
8488     case '%':
8489       consputc('%');
8490       break;
8491     default:
8492       
8493       consputc('%');
8494       consputc(c);
8495       break;
8496     }
8497   }
8498 
8499 
8500   if(locking)
8501     release(&cons.lock);
8502 }
8503 
8504 void
8505 panic(char *s)
8506 {
8507   int i;
8508   uint pcs[10];
8509 
8510   cli();
8511   cons.locking = 0;
8512   cprintf("cpu with apicid %d: panic: ", cpu->apicid);
8513   cprintf(s);
8514   cprintf("\n");
8515   getcallerpcs(&s, pcs);
8516   for(i=0; i<10; i++)
8517     cprintf(" %p", pcs[i]);
8518   panicked = 1; 
8519   for(;;)
8520     ;
8521 }
8522 
8523 
8524 
8525 
8526 
8527 
8528 
8529 
8530 
8531 
8532 
8533 
8534 
8535 
8536 
8537 
8538 
8539 
8540 
8541 
8542 
8543 
8544 
8545 
8546 
8547 
8548 
8549 
8550 #define BACKSPACE 0x100
8551 #define CRTPORT 0x3d4
8552 static ushort *crt = (ushort*)P2V(0xb8000);  
8553 
8554 static void
8555 cgaputc(int c)
8556 {
8557   int pos;
8558 
8559   
8560   outb(CRTPORT, 14);
8561   pos = inb(CRTPORT+1) << 8;
8562   outb(CRTPORT, 15);
8563   pos |= inb(CRTPORT+1);
8564 
8565   if(c == '\n')
8566     pos += 80 - pos%80;
8567   else if(c == BACKSPACE){
8568     if(pos > 0) --pos;
8569   } else
8570     crt[pos++] = (c&0xff) | 0x0700;  
8571 
8572   if(pos < 0 || pos > 25*80)
8573     panic("pos under/overflow");
8574 
8575   if((pos/80) >= 24){  
8576     memmove(crt, crt+80, sizeof(crt[0])*23*80);
8577     pos -= 80;
8578     memset(crt+pos, 0, sizeof(crt[0])*(24*80 - pos));
8579   }
8580 
8581   outb(CRTPORT, 14);
8582   outb(CRTPORT+1, pos>>8);
8583   outb(CRTPORT, 15);
8584   outb(CRTPORT+1, pos);
8585   crt[pos] = ' ' | 0x0700;
8586 }
8587 
8588 
8589 
8590 
8591 
8592 
8593 
8594 
8595 
8596 
8597 
8598 
8599 
8600 void
8601 consputc(int c)
8602 {
8603   if(panicked){
8604     cli();
8605     for(;;)
8606       ;
8607   }
8608 
8609   if(c == BACKSPACE){
8610     uartputc('\b'); uartputc(' '); uartputc('\b');
8611   } else
8612     uartputc(c);
8613   cgaputc(c);
8614 }
8615 
8616 #define INPUT_BUF 128
8617 struct {
8618   char buf[INPUT_BUF];
8619   uint r;  
8620   uint w;  
8621   uint e;  
8622 } input;
8623 
8624 #define C(x)  ((x)-'@')  
8625 
8626 void
8627 consoleintr(int (*getc)(void))
8628 {
8629   int c, doprocdump = 0;
8630 
8631   acquire(&cons.lock);
8632   while((c = getc()) >= 0){
8633     switch(c){
8634     case C('P'):  
8635       
8636       doprocdump = 1;
8637       break;
8638     case C('U'):  
8639       while(input.e != input.w &&
8640             input.buf[(input.e-1) % INPUT_BUF] != '\n'){
8641         input.e--;
8642         consputc(BACKSPACE);
8643       }
8644       break;
8645     case C('H'): case '\x7f':  
8646       if(input.e != input.w){
8647         input.e--;
8648         consputc(BACKSPACE);
8649       }
8650       break;
8651     default:
8652       if(c != 0 && input.e-input.r < INPUT_BUF){
8653         c = (c == '\r') ? '\n' : c;
8654         input.buf[input.e++ % INPUT_BUF] = c;
8655         consputc(c);
8656         if(c == '\n' || c == C('D') || input.e == input.r+INPUT_BUF){
8657           input.w = input.e;
8658           wakeup(&input.r);
8659         }
8660       }
8661       break;
8662     }
8663   }
8664   release(&cons.lock);
8665   if(doprocdump) {
8666     procdump();  
8667   }
8668 }
8669 
8670 int
8671 consoleread(struct inode *ip, char *dst, int n)
8672 {
8673   uint target;
8674   int c;
8675 
8676   iunlock(ip);
8677   target = n;
8678   acquire(&cons.lock);
8679   while(n > 0){
8680     while(input.r == input.w){
8681       if(proc->killed){
8682         release(&cons.lock);
8683         ilock(ip);
8684         return -1;
8685       }
8686       sleep(&input.r, &cons.lock);
8687     }
8688     c = input.buf[input.r++ % INPUT_BUF];
8689     if(c == C('D')){  
8690       if(n < target){
8691         
8692         
8693         input.r--;
8694       }
8695       break;
8696     }
8697     *dst++ = c;
8698     --n;
8699     if(c == '\n')
8700       break;
8701   }
8702   release(&cons.lock);
8703   ilock(ip);
8704 
8705   return target - n;
8706 }
8707 
8708 int
8709 consolewrite(struct inode *ip, char *buf, int n)
8710 {
8711   int i;
8712 
8713   iunlock(ip);
8714   acquire(&cons.lock);
8715   for(i = 0; i < n; i++)
8716     consputc(buf[i] & 0xff);
8717   release(&cons.lock);
8718   ilock(ip);
8719 
8720   return n;
8721 }
8722 
8723 void
8724 consoleinit(void)
8725 {
8726   initlock(&cons.lock, "console");
8727 
8728   devsw[CONSOLE].write = consolewrite;
8729   devsw[CONSOLE].read = consoleread;
8730   cons.locking = 1;
8731 
8732   picenable(IRQ_KBD);
8733   ioapicenable(IRQ_KBD, 0);
8734 }
8735 
8736 
8737 
8738 
8739 
8740 
8741 
8742 
8743 
8744 
8745 
8746 
8747 
8748 
8749 
8750 
8751 
8752 
8753 
8754 #include "types.h"
8755 #include "defs.h"
8756 #include "traps.h"
8757 #include "x86.h"
8758 
8759 #define IO_TIMER1       0x040           
8760 
8761 
8762 
8763 
8764 
8765 #define TIMER_FREQ      1193182
8766 #define TIMER_DIV(x)    ((TIMER_FREQ+(x)/2)/(x))
8767 
8768 #define TIMER_MODE      (IO_TIMER1 + 3) 
8769 #define TIMER_SEL0      0x00    
8770 #define TIMER_RATEGEN   0x04    
8771 #define TIMER_16BIT     0x30    
8772 
8773 void
8774 timerinit(void)
8775 {
8776   
8777   outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
8778   outb(IO_TIMER1, TIMER_DIV(100) % 256);
8779   outb(IO_TIMER1, TIMER_DIV(100) / 256);
8780   picenable(IRQ_TIMER);
8781 }
8782 
8783 
8784 
8785 
8786 
8787 
8788 
8789 
8790 
8791 
8792 
8793 
8794 
8795 
8796 
8797 
8798 
8799 
8800 
8801 
8802 #include "types.h"
8803 #include "defs.h"
8804 #include "param.h"
8805 #include "traps.h"
8806 #include "spinlock.h"
8807 #include "sleeplock.h"
8808 #include "fs.h"
8809 #include "file.h"
8810 #include "mmu.h"
8811 #include "proc.h"
8812 #include "x86.h"
8813 
8814 #define COM1    0x3f8
8815 
8816 static int uart;    
8817 
8818 void
8819 uartinit(void)
8820 {
8821   char *p;
8822 
8823   
8824   outb(COM1+2, 0);
8825 
8826   
8827   outb(COM1+3, 0x80);    
8828   outb(COM1+0, 115200/9600);
8829   outb(COM1+1, 0);
8830   outb(COM1+3, 0x03);    
8831   outb(COM1+4, 0);
8832   outb(COM1+1, 0x01);    
8833 
8834   
8835   if(inb(COM1+5) == 0xFF)
8836     return;
8837   uart = 1;
8838 
8839   
8840   
8841   inb(COM1+2);
8842   inb(COM1+0);
8843   picenable(IRQ_COM1);
8844   ioapicenable(IRQ_COM1, 0);
8845 
8846   
8847   for(p="xv6...\n"; *p; p++)
8848     uartputc(*p);
8849 }
8850 void
8851 uartputc(int c)
8852 {
8853   int i;
8854 
8855   if(!uart)
8856     return;
8857   for(i = 0; i < 128 && !(inb(COM1+5) & 0x20); i++)
8858     microdelay(10);
8859   outb(COM1+0, c);
8860 }
8861 
8862 static int
8863 uartgetc(void)
8864 {
8865   if(!uart)
8866     return -1;
8867   if(!(inb(COM1+5) & 0x01))
8868     return -1;
8869   return inb(COM1+0);
8870 }
8871 
8872 void
8873 uartintr(void)
8874 {
8875   consoleintr(uartgetc);
8876 }
8877 
8878 
8879 
8880 
8881 
8882 
8883 
8884 
8885 
8886 
8887 
8888 
8889 
8890 
8891 
8892 
8893 
8894 
8895 
8896 
8897 
8898 
8899 
8900 
8901 
8902 
8903 
8904 
8905 
8906 
8907 
8908 .globl start
8909 start:
8910   pushl $argv
8911   pushl $init
8912   pushl $0  
8913   movl $SYS_exec, %eax
8914   int $T_SYSCALL
8915 
8916 
8917 exit:
8918   movl $SYS_exit, %eax
8919   int $T_SYSCALL
8920   jmp exit
8921 
8922 
8923 init:
8924   .string "/init\0"
8925 
8926 
8927 .p2align 2
8928 argv:
8929   .long init
8930   .long 0
8931 
8932 
8933 
8934 
8935 
8936 
8937 
8938 
8939 
8940 
8941 
8942 
8943 
8944 
8945 
8946 
8947 
8948 
8949 
8950 
8951 
8952 
8953 
8954 
8955 
8956 
8957 
8958 
8959 
8960 
8961 
8962 
8963 
8964 
8965 
8966 
8967 
8968 
8969 
8970 
8971 
8972 
8973 
8974   .globl name; \
8975   name: \
8976     movl $SYS_ 
8977     int $T_SYSCALL; \
8978     ret
8979 
8980 SYSCALL(fork)
8981 SYSCALL(exit)
8982 SYSCALL(wait)
8983 SYSCALL(pipe)
8984 SYSCALL(read)
8985 SYSCALL(write)
8986 SYSCALL(close)
8987 SYSCALL(kill)
8988 SYSCALL(exec)
8989 SYSCALL(open)
8990 SYSCALL(mknod)
8991 SYSCALL(unlink)
8992 SYSCALL(fstat)
8993 SYSCALL(link)
8994 SYSCALL(mkdir)
8995 SYSCALL(chdir)
8996 SYSCALL(dup)
8997 SYSCALL(getpid)
8998 SYSCALL(sbrk)
8999 SYSCALL(sleep)
9000 SYSCALL(uptime)
9001 SYSCALL(date)
9002 
9003 
9004 
9005 
9006 
9007 
9008 
9009 
9010 
9011 
9012 
9013 
9014 
9015 
9016 
9017 
9018 
9019 
9020 
9021 
9022 
9023 
9024 
9025 
9026 
9027 
9028 
9029 
9030 
9031 
9032 
9033 
9034 
9035 
9036 
9037 
9038 
9039 
9040 
9041 
9042 
9043 
9044 
9045 
9046 
9047 
9048 
9049 
9050 
9051 
9052 #include "types.h"
9053 #include "stat.h"
9054 #include "user.h"
9055 #include "fcntl.h"
9056 
9057 char *argv[] = { "sh", 0 };
9058 
9059 int
9060 main(void)
9061 {
9062   int pid, wpid;
9063 
9064   if(open("console", O_RDWR) < 0){
9065     mknod("console", 1, 1);
9066     open("console", O_RDWR);
9067   }
9068   dup(0);  
9069   dup(0);  
9070 
9071   for(;;){
9072     printf(1, "init: starting sh\n");
9073     pid = fork();
9074     if(pid < 0){
9075       printf(1, "init: fork failed\n");
9076       exit();
9077     }
9078     if(pid == 0){
9079       exec("sh", argv);
9080       printf(1, "init: exec sh failed\n");
9081       exit();
9082     }
9083     while((wpid=wait()) >= 0 && wpid != pid)
9084       printf(1, "zombie!\n");
9085   }
9086 }
9087 
9088 
9089 
9090 
9091 
9092 
9093 
9094 
9095 
9096 
9097 
9098 
9099 
9100 
9101 
9102 #include "types.h"
9103 #include "user.h"
9104 #include "fcntl.h"
9105 
9106 
9107 #define EXEC  1
9108 #define REDIR 2
9109 #define PIPE  3
9110 #define LIST  4
9111 #define BACK  5
9112 
9113 #define MAXARGS 10
9114 
9115 struct cmd {
9116   int type;
9117 };
9118 
9119 struct execcmd {
9120   int type;
9121   char *argv[MAXARGS];
9122   char *eargv[MAXARGS];
9123 };
9124 
9125 struct redircmd {
9126   int type;
9127   struct cmd *cmd;
9128   char *file;
9129   char *efile;
9130   int mode;
9131   int fd;
9132 };
9133 
9134 struct pipecmd {
9135   int type;
9136   struct cmd *left;
9137   struct cmd *right;
9138 };
9139 
9140 struct listcmd {
9141   int type;
9142   struct cmd *left;
9143   struct cmd *right;
9144 };
9145 
9146 struct backcmd {
9147   int type;
9148   struct cmd *cmd;
9149 };
9150 int fork1(void);  
9151 void panic(char*);
9152 struct cmd *parsecmd(char*);
9153 
9154 
9155 void
9156 runcmd(struct cmd *cmd)
9157 {
9158   int p[2];
9159   struct backcmd *bcmd;
9160   struct execcmd *ecmd;
9161   struct listcmd *lcmd;
9162   struct pipecmd *pcmd;
9163   struct redircmd *rcmd;
9164 
9165   if(cmd == 0)
9166     exit();
9167 
9168   switch(cmd->type){
9169   default:
9170     panic("runcmd");
9171 
9172   case EXEC:
9173     ecmd = (struct execcmd*)cmd;
9174     if(ecmd->argv[0] == 0)
9175       exit();
9176     exec(ecmd->argv[0], ecmd->argv);
9177     printf(2, "exec %s failed\n", ecmd->argv[0]);
9178     break;
9179 
9180   case REDIR:
9181     rcmd = (struct redircmd*)cmd;
9182     close(rcmd->fd);
9183     if(open(rcmd->file, rcmd->mode) < 0){
9184       printf(2, "open %s failed\n", rcmd->file);
9185       exit();
9186     }
9187     runcmd(rcmd->cmd);
9188     break;
9189 
9190   case LIST:
9191     lcmd = (struct listcmd*)cmd;
9192     if(fork1() == 0)
9193       runcmd(lcmd->left);
9194     wait();
9195     runcmd(lcmd->right);
9196     break;
9197 
9198 
9199 
9200   case PIPE:
9201     pcmd = (struct pipecmd*)cmd;
9202     if(pipe(p) < 0)
9203       panic("pipe");
9204     if(fork1() == 0){
9205       close(1);
9206       dup(p[1]);
9207       close(p[0]);
9208       close(p[1]);
9209       runcmd(pcmd->left);
9210     }
9211     if(fork1() == 0){
9212       close(0);
9213       dup(p[0]);
9214       close(p[0]);
9215       close(p[1]);
9216       runcmd(pcmd->right);
9217     }
9218     close(p[0]);
9219     close(p[1]);
9220     wait();
9221     wait();
9222     break;
9223 
9224   case BACK:
9225     bcmd = (struct backcmd*)cmd;
9226     if(fork1() == 0)
9227       runcmd(bcmd->cmd);
9228     break;
9229   }
9230   exit();
9231 }
9232 
9233 int
9234 getcmd(char *buf, int nbuf)
9235 {
9236   printf(2, "$ ");
9237   memset(buf, 0, nbuf);
9238   gets(buf, nbuf);
9239   if(buf[0] == 0) 
9240     return -1;
9241   return 0;
9242 }
9243 
9244 
9245 
9246 
9247 
9248 
9249 
9250 int
9251 main(void)
9252 {
9253   static char buf[100];
9254   int fd;
9255 
9256   
9257   while((fd = open("console", O_RDWR)) >= 0){
9258     if(fd >= 3){
9259       close(fd);
9260       break;
9261     }
9262   }
9263 
9264   
9265   while(getcmd(buf, sizeof(buf)) >= 0){
9266     if(buf[0] == 'c' && buf[1] == 'd' && buf[2] == ' '){
9267       
9268       buf[strlen(buf)-1] = 0;  
9269       if(chdir(buf+3) < 0)
9270         printf(2, "cannot cd %s\n", buf+3);
9271       continue;
9272     }
9273     if(fork1() == 0)
9274       runcmd(parsecmd(buf));
9275     wait();
9276   }
9277   exit();
9278 }
9279 
9280 void
9281 panic(char *s)
9282 {
9283   printf(2, "%s\n", s);
9284   exit();
9285 }
9286 
9287 int
9288 fork1(void)
9289 {
9290   int pid;
9291 
9292   pid = fork();
9293   if(pid == -1)
9294     panic("fork");
9295   return pid;
9296 }
9297 
9298 
9299 
9300 
9301 
9302 struct cmd*
9303 execcmd(void)
9304 {
9305   struct execcmd *cmd;
9306 
9307   cmd = malloc(sizeof(*cmd));
9308   memset(cmd, 0, sizeof(*cmd));
9309   cmd->type = EXEC;
9310   return (struct cmd*)cmd;
9311 }
9312 
9313 struct cmd*
9314 redircmd(struct cmd *subcmd, char *file, char *efile, int mode, int fd)
9315 {
9316   struct redircmd *cmd;
9317 
9318   cmd = malloc(sizeof(*cmd));
9319   memset(cmd, 0, sizeof(*cmd));
9320   cmd->type = REDIR;
9321   cmd->cmd = subcmd;
9322   cmd->file = file;
9323   cmd->efile = efile;
9324   cmd->mode = mode;
9325   cmd->fd = fd;
9326   return (struct cmd*)cmd;
9327 }
9328 
9329 struct cmd*
9330 pipecmd(struct cmd *left, struct cmd *right)
9331 {
9332   struct pipecmd *cmd;
9333 
9334   cmd = malloc(sizeof(*cmd));
9335   memset(cmd, 0, sizeof(*cmd));
9336   cmd->type = PIPE;
9337   cmd->left = left;
9338   cmd->right = right;
9339   return (struct cmd*)cmd;
9340 }
9341 
9342 
9343 
9344 
9345 
9346 
9347 
9348 
9349 
9350 struct cmd*
9351 listcmd(struct cmd *left, struct cmd *right)
9352 {
9353   struct listcmd *cmd;
9354 
9355   cmd = malloc(sizeof(*cmd));
9356   memset(cmd, 0, sizeof(*cmd));
9357   cmd->type = LIST;
9358   cmd->left = left;
9359   cmd->right = right;
9360   return (struct cmd*)cmd;
9361 }
9362 
9363 struct cmd*
9364 backcmd(struct cmd *subcmd)
9365 {
9366   struct backcmd *cmd;
9367 
9368   cmd = malloc(sizeof(*cmd));
9369   memset(cmd, 0, sizeof(*cmd));
9370   cmd->type = BACK;
9371   cmd->cmd = subcmd;
9372   return (struct cmd*)cmd;
9373 }
9374 
9375 
9376 
9377 
9378 
9379 
9380 
9381 
9382 
9383 
9384 
9385 
9386 
9387 
9388 
9389 
9390 
9391 
9392 
9393 
9394 
9395 
9396 
9397 
9398 
9399 
9400 
9401 
9402 char whitespace[] = " \t\r\n\v";
9403 char symbols[] = "<|>&;()";
9404 
9405 int
9406 gettoken(char **ps, char *es, char **q, char **eq)
9407 {
9408   char *s;
9409   int ret;
9410 
9411   s = *ps;
9412   while(s < es && strchr(whitespace, *s))
9413     s++;
9414   if(q)
9415     *q = s;
9416   ret = *s;
9417   switch(*s){
9418   case 0:
9419     break;
9420   case '|':
9421   case '(':
9422   case ')':
9423   case ';':
9424   case '&':
9425   case '<':
9426     s++;
9427     break;
9428   case '>':
9429     s++;
9430     if(*s == '>'){
9431       ret = '+';
9432       s++;
9433     }
9434     break;
9435   default:
9436     ret = 'a';
9437     while(s < es && !strchr(whitespace, *s) && !strchr(symbols, *s))
9438       s++;
9439     break;
9440   }
9441   if(eq)
9442     *eq = s;
9443 
9444   while(s < es && strchr(whitespace, *s))
9445     s++;
9446   *ps = s;
9447   return ret;
9448 }
9449 
9450 int
9451 peek(char **ps, char *es, char *toks)
9452 {
9453   char *s;
9454 
9455   s = *ps;
9456   while(s < es && strchr(whitespace, *s))
9457     s++;
9458   *ps = s;
9459   return *s && strchr(toks, *s);
9460 }
9461 
9462 struct cmd *parseline(char**, char*);
9463 struct cmd *parsepipe(char**, char*);
9464 struct cmd *parseexec(char**, char*);
9465 struct cmd *nulterminate(struct cmd*);
9466 
9467 struct cmd*
9468 parsecmd(char *s)
9469 {
9470   char *es;
9471   struct cmd *cmd;
9472 
9473   es = s + strlen(s);
9474   cmd = parseline(&s, es);
9475   peek(&s, es, "");
9476   if(s != es){
9477     printf(2, "leftovers: %s\n", s);
9478     panic("syntax");
9479   }
9480   nulterminate(cmd);
9481   return cmd;
9482 }
9483 
9484 struct cmd*
9485 parseline(char **ps, char *es)
9486 {
9487   struct cmd *cmd;
9488 
9489   cmd = parsepipe(ps, es);
9490   while(peek(ps, es, "&")){
9491     gettoken(ps, es, 0, 0);
9492     cmd = backcmd(cmd);
9493   }
9494   if(peek(ps, es, ";")){
9495     gettoken(ps, es, 0, 0);
9496     cmd = listcmd(cmd, parseline(ps, es));
9497   }
9498   return cmd;
9499 }
9500 struct cmd*
9501 parsepipe(char **ps, char *es)
9502 {
9503   struct cmd *cmd;
9504 
9505   cmd = parseexec(ps, es);
9506   if(peek(ps, es, "|")){
9507     gettoken(ps, es, 0, 0);
9508     cmd = pipecmd(cmd, parsepipe(ps, es));
9509   }
9510   return cmd;
9511 }
9512 
9513 struct cmd*
9514 parseredirs(struct cmd *cmd, char **ps, char *es)
9515 {
9516   int tok;
9517   char *q, *eq;
9518 
9519   while(peek(ps, es, "<>")){
9520     tok = gettoken(ps, es, 0, 0);
9521     if(gettoken(ps, es, &q, &eq) != 'a')
9522       panic("missing file for redirection");
9523     switch(tok){
9524     case '<':
9525       cmd = redircmd(cmd, q, eq, O_RDONLY, 0);
9526       break;
9527     case '>':
9528       cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);
9529       break;
9530     case '+':  
9531       cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);
9532       break;
9533     }
9534   }
9535   return cmd;
9536 }
9537 
9538 
9539 
9540 
9541 
9542 
9543 
9544 
9545 
9546 
9547 
9548 
9549 
9550 struct cmd*
9551 parseblock(char **ps, char *es)
9552 {
9553   struct cmd *cmd;
9554 
9555   if(!peek(ps, es, "("))
9556     panic("parseblock");
9557   gettoken(ps, es, 0, 0);
9558   cmd = parseline(ps, es);
9559   if(!peek(ps, es, ")"))
9560     panic("syntax - missing )");
9561   gettoken(ps, es, 0, 0);
9562   cmd = parseredirs(cmd, ps, es);
9563   return cmd;
9564 }
9565 
9566 struct cmd*
9567 parseexec(char **ps, char *es)
9568 {
9569   char *q, *eq;
9570   int tok, argc;
9571   struct execcmd *cmd;
9572   struct cmd *ret;
9573 
9574   if(peek(ps, es, "("))
9575     return parseblock(ps, es);
9576 
9577   ret = execcmd();
9578   cmd = (struct execcmd*)ret;
9579 
9580   argc = 0;
9581   ret = parseredirs(ret, ps, es);
9582   while(!peek(ps, es, "|)&;")){
9583     if((tok=gettoken(ps, es, &q, &eq)) == 0)
9584       break;
9585     if(tok != 'a')
9586       panic("syntax");
9587     cmd->argv[argc] = q;
9588     cmd->eargv[argc] = eq;
9589     argc++;
9590     if(argc >= MAXARGS)
9591       panic("too many args");
9592     ret = parseredirs(ret, ps, es);
9593   }
9594   cmd->argv[argc] = 0;
9595   cmd->eargv[argc] = 0;
9596   return ret;
9597 }
9598 
9599 
9600 
9601 struct cmd*
9602 nulterminate(struct cmd *cmd)
9603 {
9604   int i;
9605   struct backcmd *bcmd;
9606   struct execcmd *ecmd;
9607   struct listcmd *lcmd;
9608   struct pipecmd *pcmd;
9609   struct redircmd *rcmd;
9610 
9611   if(cmd == 0)
9612     return 0;
9613 
9614   switch(cmd->type){
9615   case EXEC:
9616     ecmd = (struct execcmd*)cmd;
9617     for(i=0; ecmd->argv[i]; i++)
9618       *ecmd->eargv[i] = 0;
9619     break;
9620 
9621   case REDIR:
9622     rcmd = (struct redircmd*)cmd;
9623     nulterminate(rcmd->cmd);
9624     *rcmd->efile = 0;
9625     break;
9626 
9627   case PIPE:
9628     pcmd = (struct pipecmd*)cmd;
9629     nulterminate(pcmd->left);
9630     nulterminate(pcmd->right);
9631     break;
9632 
9633   case LIST:
9634     lcmd = (struct listcmd*)cmd;
9635     nulterminate(lcmd->left);
9636     nulterminate(lcmd->right);
9637     break;
9638 
9639   case BACK:
9640     bcmd = (struct backcmd*)cmd;
9641     nulterminate(bcmd->cmd);
9642     break;
9643   }
9644   return cmd;
9645 }
9646 
9647 
9648 
9649 
9650 
9651 
9652 
9653 
9654 
9655 
9656 
9657 
9658 
9659 .code16                       
9660 .globl start
9661 start:                        
9662   cli                         
9663 
9664   
9665   xorw    %ax,%ax             
9666   movw    %ax,%ds             
9667   movw    %ax,%es             
9668   movw    %ax,%ss             
9669 
9670   
9671   
9672   
9673   
9674   
9675 seta20.1:
9676   inb     $0x64,%al               
9677   testb   $0x2,%al
9678   jnz     seta20.1
9679 
9680   movb    $0xd1,%al               
9681   outb    %al,$0x64
9682 
9683 seta20.2:
9684   inb     $0x64,%al               
9685   testb   $0x2,%al
9686   jnz     seta20.2
9687 
9688   movb    $0xdf,%al               
9689   outb    %al,$0x60
9690 
9691   
9692   
9693   
9694   lgdt    gdtdesc
9695   movl    %cr0, %eax
9696   orl     $CR0_PE, %eax
9697   movl    %eax, %cr0
9698 
9699 
9700   
9701   
9702   
9703   
9704   
9705   
9706   
9707   
9708   ljmp    $(SEG_KCODE<<3), $start32
9709 
9710 .code32  
9711 start32:
9712   
9713   movw    $(SEG_KDATA<<3), %ax    
9714   movw    %ax, %ds                
9715   movw    %ax, %es                
9716   movw    %ax, %ss                
9717   movw    $0, %ax                 
9718   movw    %ax, %fs                
9719   movw    %ax, %gs                
9720 
9721   
9722   movl    $start, %esp
9723   call    bootmain
9724 
9725   
9726   
9727   movw    $0x8a00, %ax            
9728   movw    %ax, %dx
9729   outw    %ax, %dx
9730   movw    $0x8ae0, %ax            
9731   outw    %ax, %dx
9732 spin:
9733   jmp     spin
9734 
9735 
9736 .p2align 2                                
9737 gdt:
9738   SEG_NULLASM                             
9739   SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)   
9740   SEG_ASM(STA_W, 0x0, 0xffffffff)         
9741 
9742 gdtdesc:
9743   .word   (gdtdesc - gdt - 1)             
9744   .long   gdt                             
9745 
9746 
9747 
9748 
9749 
9750 
9751 
9752 
9753 
9754 
9755 
9756 
9757 #include "types.h"
9758 #include "elf.h"
9759 #include "x86.h"
9760 #include "memlayout.h"
9761 
9762 #define SECTSIZE  512
9763 
9764 void readseg(uchar*, uint, uint);
9765 
9766 void
9767 bootmain(void)
9768 {
9769   struct elfhdr *elf;
9770   struct proghdr *ph, *eph;
9771   void (*entry)(void);
9772   uchar* pa;
9773 
9774   elf = (struct elfhdr*)0x10000;  
9775 
9776   
9777   
9778   
9779   readseg((uchar*)elf, 4096, 0);
9780 
9781   
9782   if(elf->magic != ELF_MAGIC)
9783     return;  
9784 
9785   
9786   ph = (struct proghdr*)((uchar*)elf + elf->phoff);
9787   eph = ph + elf->phnum;
9788   for(; ph < eph; ph++){
9789     pa = (uchar*)ph->paddr;
9790     readseg(pa, ph->filesz, ph->off);
9791     if(ph->memsz > ph->filesz)
9792       stosb(pa + ph->filesz, 0, ph->memsz - ph->filesz);
9793   }
9794 
9795   
9796   
9797   entry = (void(*)(void))(elf->entry);
9798   entry();
9799 }
9800 void
9801 waitdisk(void)
9802 {
9803   
9804   while((inb(0x1F7) & 0xC0) != 0x40)
9805     ;
9806 }
9807 
9808 
9809 void
9810 readsect(void *dst, uint offset)
9811 {
9812   
9813   waitdisk();
9814   outb(0x1F2, 1);   
9815   outb(0x1F3, offset);
9816   outb(0x1F4, offset >> 8);
9817   outb(0x1F5, offset >> 16);
9818   outb(0x1F6, (offset >> 24) | 0xE0);
9819   outb(0x1F7, 0x20);  
9820 
9821   
9822   waitdisk();
9823   insl(0x1F0, dst, SECTSIZE/4);
9824 }
9825 
9826 
9827 
9828 void
9829 readseg(uchar* pa, uint count, uint offset)
9830 {
9831   uchar* epa;
9832 
9833   epa = pa + count;
9834 
9835   
9836   pa -= offset % SECTSIZE;
9837 
9838   
9839   offset = (offset / SECTSIZE) + 1;
9840 
9841   
9842   
9843   
9844   for(; pa < epa; pa += SECTSIZE, offset++)
9845     readsect(pa, offset);
9846 }
9847 
9848 
9849 
